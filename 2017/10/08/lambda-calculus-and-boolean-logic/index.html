<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Lambda Calculus - Boolean logic.</title>
  <meta name="description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">
  <meta name="author" content="Bruno Bonacci">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bits and pieces">
  <meta name="twitter:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Bits and pieces">
  <meta property="og:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.brunobonacci.com//2017/10/08/lambda-calculus-and-boolean-logic/">
  <link rel="alternate" type="application/rss+xml" title="Bits and pieces" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Bits and pieces">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Bits and pieces</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/projects" title="link to Bits and pieces Projects" class="blog-button">Projects</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="link to Bits and pieces blog" class="blog-button">Blog</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/tags" title="link to Bits and pieces tags" class="blog-button">Tags</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/categories" title="link to Bits and pieces categories" class="blog-button">Categories</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/BrunoBonacci" title="@BrunoBonacci on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/brunobonacci" title="brunobonacci on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/BrunoBonacci" title="BrunoBonacci on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="8 Oct 2017" class="post-meta__date date">8 Oct 2017</time> &#8226; <span class="post-meta__tags">on <a href="/tags/#Lambda Calculus">Lambda Calculus</a> <a href="/tags/#Clojure">Clojure</a> </span>
    </div>
    <h1 class="post-title">Lambda Calculus - Boolean logic.</h1>
  </header>

  <section class="post">
    <p>In this post I will introduce some of the basic concepts of the
<em>Lambda Calculus</em> and use them to define basic terms and operators of
the boolean logic.</p>

<p>Recently, I was challenged to write a Clojure’s macro called <code class="highlighter-rouge">IF</code>
which behaves like the <code class="highlighter-rouge">clojure.core/if</code> but doesn’t use anything that
expands to it. This means that you can exclude pretty much all the
usual suspects in the core: <code class="highlighter-rouge">cond</code>, <code class="highlighter-rouge">condp</code>, <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code>, <code class="highlighter-rouge">case</code>,
<code class="highlighter-rouge">cond-&gt;</code>, etc.</p>

<p>After feeling a bit lost for about a minute or so, I understood that
to solve this challenge I had to go back the primitive element of
computation. For example on <code class="highlighter-rouge">x86</code> the <code class="highlighter-rouge">if</code> it is implemented as a
combination of a comparison operation <code class="highlighter-rouge">cmp</code> and a jump operation <code class="highlighter-rouge">jz</code>
(jump if zero) <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<p>My best guess to solve the challenge was to artificially <em>jump to a
location</em>. However in Clojure there is no <em>jump</em> instruction so the
only way to simulate something similar is to encode the jump location
into a map.  Therefore my solution was something like:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="p">[</span><span class="nb">test</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w">
       </span><span class="o">`</span><span class="p">(({</span><span class="n">true</span><span class="w">  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">t</span><span class="p">)</span><span class="w">
           </span><span class="n">false</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">f</span><span class="p">)}</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="o">~</span><span class="nb">test</span><span class="p">))))</span><span class="w">
</span></code></pre>
</div>

<p>In other words:</p>

<ul>
  <li>
    <p>evaluate the <code class="highlighter-rouge">test</code> expression and convert the result into a
boolean value.</p>
  </li>
  <li>
    <p>create a map with <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> as key and a <em>thunk</em> function
as a value which wraps the truthy and falsey expressions.</p>
  </li>
  <li>
    <p>use the map as function to lookup the result of the <code class="highlighter-rouge">test</code>.</p>
  </li>
  <li>
    <p>evaluate the resulting thunk by wrapping the expression with an
additional pair of brackets <code class="highlighter-rouge">()</code>.</p>
  </li>
</ul>

<p>You can use this macro pretty much like the <code class="highlighter-rouge">clojure.core/if</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"KO"</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; "KO"
</span><span class="w">
   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"KO"</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; "OK"
</span><span class="w">
   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"KO"</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; "KO"
</span></code></pre>
</div>

<p>Although this works, I wasn’t too happy with the solution. I thought
there must be <em>a more elegant solution</em>.  Since Clojure is a
functional language, I searched inspiration on the foundation of
functional programming languages and went back to <em>Alonzo Church</em> and
the <em>Lambda Calculus</em> (<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>-<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>). The Lambda Calculus defines the concept of
functions as computational boxes made only of very, very, very simple
elements.</p>

<p>The <em>Lambda Calculus</em> defines the following elements:</p>
<ul>
  <li>the <code class="highlighter-rouge">λ</code> sign to denote a function.</li>
  <li>followed by a parameter name</li>
  <li>then a dot <code class="highlighter-rouge">.</code></li>
  <li>and followed by an expression which is the body of the lambda.</li>
  <li>a set of parenthesis can wrap the expression to make it unambiguous.</li>
  <li>lambdas can optionally be <em>labelled</em>, in which case the label when
found in another expression it expands to the lambda which it
labels.</li>
</ul>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">      </span><span class="p">(</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;   |  \-&gt; body
</span><span class="w">   </span><span class="c1">;;   \----&gt; parameter
</span></code></pre>
</div>

<p>For example a <code class="highlighter-rouge">λ-abstraction</code> (or <code class="highlighter-rouge">λ-expression</code>) which increments a
number by one would be defined as:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">      </span><span class="p">(</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;   |  ----
</span><span class="w">   </span><span class="c1">;;   |  \-&gt; body
</span><span class="w">   </span><span class="c1">;;   \----&gt; variable
</span></code></pre>
</div>

<p>Every time the <code class="highlighter-rouge">λ-expression</code> is applied to an argument the expression
is expanded by replacing the term with its body, and replacing the
variables with their values. For example:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">((</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="w">     </span><span class="nf">3</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w">   </span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; 4
</span></code></pre>
</div>

<p>A <code class="highlighter-rouge">λ-expression</code> can also be <em>labelled</em>, once labelled the label can be
used in place of the expression and, if applied, it is replaced with
its definition.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="n">INC</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">INC</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
   </span><span class="p">((</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="w">     </span><span class="nf">3</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w">   </span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; 4
</span></code></pre>
</div>

<p><code class="highlighter-rouge">λ-expressions</code> can also have multiple parameters.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="err">λ</span><span class="n">x.</span><span class="w"> </span><span class="err">λ</span><span class="n">y.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; which can be simplified as:
</span><span class="w">
   </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<h3 id="boolean-logic">Boolean logic.</h3>

<p>Let’s define <code class="highlighter-rouge">TRUE</code> as a <code class="highlighter-rouge">λ-expression</code> which takes two parameters and
returns the first.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="n">TRUE</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>Similarly, <code class="highlighter-rouge">FALSE</code> takes two parameters, but returns the second one:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="n">FALSE</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>Once we defined the basic boolean values then we can define logical
operators such as: <code class="highlighter-rouge">AND</code>, <code class="highlighter-rouge">OR</code> and <code class="highlighter-rouge">NOT</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="n">AND</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">))</span><span class="w">
   </span><span class="n">OR</span><span class="w">  </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)))</span><span class="w">
   </span><span class="n">NOT</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">b.</span><span class="w">  </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>Now let’s try to test this logical operators:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; expanding AND
</span><span class="w">   </span><span class="p">((</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w">    </span><span class="p">(</span><span class="nf">y</span><span class="w">     </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">))</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; replacing values into expansion
</span><span class="w">   </span><span class="p">(</span><span class="w">       </span><span class="nf">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nf">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; expanding TRUE
</span><span class="w">   </span><span class="p">((</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; replacing values into expansion
</span><span class="w">   </span><span class="p">(</span><span class="nf">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; expanding FALSE
</span><span class="w">   </span><span class="p">((</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; replacing values into expansion
</span><span class="w">   </span><span class="c1">;; which is also the final result.
</span><span class="w">   </span><span class="n">FALSE</span><span class="w">
</span></code></pre>
</div>

<p>Once we have these three basic operators we can implement the entire
boolean logic including something that behaves like <code class="highlighter-rouge">IF</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="n">IF</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">bxy.</span><span class="w"> </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>Where <code class="highlighter-rouge">b</code> is the result of the boolean logic predicate expression, <code class="highlighter-rouge">x</code>
is the value to return when the <code class="highlighter-rouge">b</code> is true, <code class="highlighter-rouge">y</code> otherwise.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">TRUE</span><span class="w">  </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; "OK"
</span><span class="w">
   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">)</span><span class="w">
   </span><span class="c1">;;=&gt; "FAIL"
</span></code></pre>
</div>

<p>Clojure is <em>unsurprisingly</em> very similar to the <em>Lambda Calculus</em> definition</p>

<p>For example:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="c1">;; Lambda Calculus' λ-expression
</span><span class="w">   </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; Clojure's λ-expression
</span><span class="w">   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>and with the label:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="c1">;; Lambda Calculus' λ-expression
</span><span class="w">   </span><span class="n">SUM</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="err">λ</span><span class="n">xy.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">

   </span><span class="c1">;; Clojure
</span><span class="w">   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">SUM</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>So if we redefine everything using Clojure’s lambdas we get something like:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">TRUE</span><span class="w">  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">

   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">NOT</span><span class="w">   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)))</span><span class="w">

   </span><span class="p">(</span><span class="nf">NOT</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">AND</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)))</span><span class="w">

   </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">   </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w">  </span><span class="c1">;;=&gt; TRUE
</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">OR</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">))))</span><span class="w">

   </span><span class="p">(</span><span class="nf">OR</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">   </span><span class="p">(</span><span class="nf">OR</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w">  </span><span class="c1">;;=&gt; TRUE
</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">IF</span><span class="w">
     </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w">

   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="p">(</span><span class="nf">NOT</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w">      </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; "OK"
</span><span class="w">   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w"> </span><span class="s">"OK"</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; "FAIL"
</span><span class="w">
</span></code></pre>
</div>

<p>At this point we pretty much have everything we need, with the only
difference that the evaluation of the <em>λ-expressions</em> in <em>Lambda
Calculus</em> is always delayed (<em>lazy evaluation</em>).  In Clojure,
function evaluation is done by first evaluating all the parameters,
and then evaluating the function itself. However, Clojure macros (and
special forms) take in input the forms (rather than the values)
allowing more fine grained control.</p>

<p>For example, our new <code class="highlighter-rouge">IF</code> function will evaluate both branches
of the expression before calling the function itself.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="c1">;; note: both branches are evaluated.
</span><span class="w">   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"OK"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">))</span><span class="w">
   </span><span class="n">OK</span><span class="w">
   </span><span class="n">FAIL</span><span class="w">
   </span><span class="c1">;;=&gt; nil
</span></code></pre>
</div>

<p>To match the behaviour of <code class="highlighter-rouge">clojure.core/if</code> we need to evaluate only
the branch which is returned. So like I did in my first <code class="highlighter-rouge">IF</code>
implementation I have to turn it into a macro and wrap each branch
into a thunk.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
     </span><span class="o">`</span><span class="p">((</span><span class="o">~</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">y</span><span class="p">))))</span><span class="w">

   </span><span class="c1">;; note: only the correct branch is evaluated.
</span><span class="w">   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"OK"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">))</span><span class="w">
   </span><span class="n">OK</span><span class="w">
   </span><span class="c1">;;=&gt; nil
</span></code></pre>
</div>

<h3 id="conclusions">Conclusions</h3>

<p>It has been an interesting journey to the origins of computational
theory and functional programming theory. It is fascinating to see
that it is possible to build pretty much anything out of very very
simple elements. <em>Lambda Calculus</em> has no concept of boolean logic or
branching operations, and yet we managed to build all common boolean
logic operators and the <code class="highlighter-rouge">if</code> special form.</p>

<p>The <em>Lambda Calculus</em> has much more to offer. Reduction logic and
combinators deserve a post on their own.</p>

<p>As final note there is to say that <code class="highlighter-rouge">clojure.core/case</code> <sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup> doesn’t
expand to <code class="highlighter-rouge">if</code> but, actually, it uses a technique which is similar to
my first solution. A map is built for every case and a thunk is
associated with every key. A the time I wrote my solution I was
unaware of this.</p>

<h3 id="final-code">Final code.</h3>

<p>Here all the final code.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">TRUE</span><span class="w">  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">

   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">NOT</span><span class="w">   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)))</span><span class="w">

   </span><span class="p">(</span><span class="nf">NOT</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">AND</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)))</span><span class="w">

   </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">   </span><span class="p">(</span><span class="nf">AND</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w">  </span><span class="c1">;;=&gt; TRUE
</span><span class="w">
   </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">OR</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nf">y</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">))))</span><span class="w">

   </span><span class="p">(</span><span class="nf">OR</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="c1">;;=&gt; FALSE
</span><span class="w">   </span><span class="p">(</span><span class="nf">OR</span><span class="w"> </span><span class="n">FALSE</span><span class="w"> </span><span class="n">TRUE</span><span class="p">)</span><span class="w">  </span><span class="c1">;;=&gt; TRUE
</span><span class="w">
   </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
       </span><span class="o">`</span><span class="p">(((</span><span class="o">~</span><span class="n">b</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">~</span><span class="n">y</span><span class="p">))))</span><span class="w">

   </span><span class="p">(</span><span class="nf">IF</span><span class="w"> </span><span class="n">TRUE</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"OK"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"FAIL"</span><span class="p">))</span><span class="w">
   </span><span class="n">OK</span><span class="w">
   </span><span class="c1">;;=&gt; nil
</span></code></pre>
</div>

<h3 id="references">References</h3>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions">X86 Assembly Control Flow</a>&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://users.dcc.uchile.cl/~abassi/Cursos/41a/lambdacalc.pdf">An Introduction to the Lambda Calculus - Goldberg 2000</a>&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://www.youtube.com/watch?v=eis11j_iGMs">Lambda Calculus - Computerphile</a>&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="https://github.com/clojure/clojure/blob/clojure-1.9.0-alpha14/src/clj/clojure/core.clj#L6579">clojure.core/case source code</a>&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'bitsandpieces2'; // required: replace example with your forum shortname
        var disqus_config = function () {
          this.page.url = 'http://blog.brunobonacci.com/2017/10/08/lambda-calculus-and-boolean-logic/';
          this.page.identifier = '/2017/10/08/lambda-calculus-and-boolean-logic';
          this.page.title = 'Lambda Calculus - Boolean logic.';
        };
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2013-2016 Bruno Bonacci. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51571233-1', 'auto');
  ga('send', 'pageview');
</script>


    </div>
  </body>
</html>
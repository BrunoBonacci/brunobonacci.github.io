<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Learn Clojure - Clojure Basics</title>
  <meta name="description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">
  <meta name="author" content="Bruno Bonacci">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bits and pieces">
  <meta name="twitter:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Bits and pieces">
  <meta property="og:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.">

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.brunobonacci.com//2016/05/11/clojure-basics/">
  <link rel="alternate" type="application/rss+xml" title="Bits and pieces" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Bits and pieces">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Bits and pieces</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, BigData, and Software Architecture.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/projects" title="link to Bits and pieces Projects" class="blog-button">Projects</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="link to Bits and pieces blog" class="blog-button">Blog</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/tags" title="link to Bits and pieces tags" class="blog-button">Tags</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/categories" title="link to Bits and pieces categories" class="blog-button">Categories</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/BrunoBonacci" title="@BrunoBonacci on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/brunobonacci" title="brunobonacci on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/BrunoBonacci" title="BrunoBonacci on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="11 May 2016" class="post-meta__date date">11 May 2016</time> &#8226; <span class="post-meta__tags">on <a href="/tags/#Clojure">Clojure</a> <a href="/tags/#REPL">REPL</a> </span>
    </div>
    <h1 class="post-title">Learn Clojure - Clojure Basics</h1>
  </header>

  <section class="post">
    <p>I will try to introduce concepts gradually
without assuming prior knowledge of Clojure (or
any other LISP dialect).  However I will assume
that you are already an experienced developer
in any other popular language such as Java,
C/C++, Python or Javascript.  General
programming concepts such as functions,
parameters, recursion, objects and common
data-structures such as: linked lists, maps (or
dictionaries), vectors and sets will be assumed
to be already known.</p>

<h3 id="the-repl">The REPL</h3>

<p>The REPL is (IMHO) one of the key Clojure
features. REPL stands for: <strong>Read Eval Print
Loop</strong> and although this is present in many
languages such as python, ruby and soon Java as
well, in Clojure it is part of the main
development workflow. In other words if you are
not using the REPL for your Clojure development
you are doing it wrong!</p>

<p>The REPL allows you to connect to a running
system, inspect runtime values, and even make
live changes in your code without having to
restart your system.</p>

<p>It is the best way to explore a system or a
dataset and get familiar with its domain.</p>

<p>In terms of feedback, the Read Eval Print Loop
is so much better than TDD, that a new
development methodology has been created/inspired..
the <strong>REPL Driven Development</strong></p>

<p>For this session we are going to use the REPL
to explore Clojure features, this might give a
glimpse of what is possible to do with the
Clojure REPL.</p>

<h3 id="clojure-syntax">Clojure syntax</h3>

<p>Clojure syntax is very simple.
A program is composed of s-expressions,
every s-expr is delimited by a set of
parenthesis. Line comments are made
with a semicolon (<code class="highlighter-rouge">;</code>) and by conventions
a full line comment is two or more consecutive
semicolons <code class="highlighter-rouge">;;</code> while and in-line comment
is only one <code class="highlighter-rouge">;</code>.</p>

<p>You can skip the evaluation and execution of a
block with the <code class="highlighter-rouge">comment</code> form, however this
isn’t a complete comment in the same way as the
semicolon, as it still get parsed by the reader
in the same way as the rest of the
code. Therefore the comment block has to be
valid Clojure code.  For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> ;; this is a valid comment
 ;; a : b : c
 ;; while this won't be readable
 (comment a : b : c)
</code></pre>
</div>

<p>The difference is that the semicolon comment is
ignored by the reader, while the <code class="highlighter-rouge">comment</code>
block is something that you could have
implemented yourself using the macros, which in
this case just tells the compiler to not
generate anything any code.</p>

<p>We will denote the output of the REPL evaluation
with by prefixing the result with <code class="highlighter-rouge">;;=&gt;</code>.
So every time you see a Clojure expression
followed by <code class="highlighter-rouge">;;=&gt;</code> and a value it means
that the value is the result of the evaluation
of last expression.</p>

<h3 id="the-function-call">The function call.</h3>

<p>The first concept I will introduce is how to
make a function call.  We will see more about
functions later, but for the moment I want to
make sure that you will understand the next few
examples.  Let’s start to make some comparisons
with method or function calls in a few
different languages</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// java and C++
myObject.myFunction(arg1, arg2, arg3);

// C
myFunction(myStruct, arg1, arg2, arg3);

;; Clojure
(my-function myObject arg1 arg2 arg3)
</code></pre>
</div>

<p>As you can see in Clojure the brackets surround
the function and all its arguments.  In object
oriented languages such as Java and C++ the
object comes before the method name or function
name. In C and Clojure the function comes
first, then followed by the target
object. Let’s see a concrete example, <em>for the
sake of the example I will omit the required
package imports.</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>// java
"Hello World!".toLowerCase();

// C - single char
tolower(*c);
// C - Whole string
for ( ; *c; ++c) *c = tolower(*c);
                     ^^^^^^^^^^^^^

;; Clojure
(lower-case "Hello World!")
</code></pre>
</div>

<p><em>NOTE: In the standard C library there is only
a function to turn a single character into its
lowercase form, that’s why there is a loop.</em></p>

<p>However in the <code class="highlighter-rouge">tolower(*c)</code> we can see the
function comes first followed by its arguments
surrounded by bracket.  In Clojure, the
expression (called <code class="highlighter-rouge">s-expr</code>) starts with an
open bracket, followed by a function followed
by a list of arguments.</p>

<p>The following code is designed to run in the
Clojure REPL, the conventions I will follow
throughout the text is to display the result of
the expression evaluation prefixed with this
evaluation marker <code class="highlighter-rouge">;;=&gt;</code>. So every time you’ll
see a Clojure expression followed by <code class="highlighter-rouge">;;=&gt;</code> and
followed by another value it means that the
result of the evaluation of the prior
expression is what follows the marker. For
example the evaluation of the expression <code class="highlighter-rouge">(+ 1
1)</code> with its result will be noted as follow:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(+ 1 1)
;;=&gt; 2
</code></pre>
</div>

<h3 id="booleans">Booleans</h3>

<p>In Clojure we have boolean values like in many
other languages.  No surprise here we have two
values <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> which just evaluate
to themselves.  Now we can use the function
<code class="highlighter-rouge">type</code> to see what is the concrete type of
these values in the host platform, and if we
check the type of these values we’ll find that
they are just simple Java <code class="highlighter-rouge">java.lang.Boolean</code>
objects.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="n">true</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Boolean
</span><span class="w">
</span></code></pre>
</div>

<p>Now boolean values are often associated to
<strong>logic programming</strong> and the concept of
<strong>“truthiness”</strong>. In strongly typed languages
such as Java you can only use boolean in
conditional operation.  Some other languages
such C/C++ have a more loose definition
<strong>“truthiness”</strong>.  <strong>In Clojure everything is
considered **true** with the exception of
<code class="highlighter-rouge">false</code> and <code class="highlighter-rouge">nil</code>.</strong></p>

<p>For example we can use the following form <code class="highlighter-rouge">(if
condition truthy falsey)</code> which evaluates the
given <code class="highlighter-rouge">condition</code> and if the condition has a
logical value of true then it will evaluate
<code class="highlighter-rouge">truthy</code> form otherwise it evaluates the
<code class="highlighter-rouge">falsey</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="s">"it's true"</span><span class="w"> </span><span class="s">"it's false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's true"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="s">"it's true"</span><span class="w"> </span><span class="s">"it's false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's false"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="s">"it's true"</span><span class="w"> </span><span class="s">"it's false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's false"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="s">"HELLO"</span><span class="w"> </span><span class="s">"it's true"</span><span class="w"> </span><span class="s">"it's false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's true"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="s">"it's true"</span><span class="w"> </span><span class="s">"it's false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's true"
</span><span class="w">
</span></code></pre>
</div>

<h3 id="numbers">Numbers</h3>

<p>Clojure has a quite unique support for
numerical values.  As you would expect every
number just evaluates to itself.</p>

<h4 id="integers">Integers</h4>

<p>They are mapped to <code class="highlighter-rouge">java.lang.Long</code>, but since
they can be indefinitely large they can be
promoted to <code class="highlighter-rouge">clojure.lang.BigInt</code> once they go
beyond the <code class="highlighter-rouge">java.lang.Long#MAX_VALUE</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="mi">1</span><span class="w"> </span><span class="c1">;;=&gt; 1
</span><span class="mi">-4</span><span class="w"> </span><span class="c1">;;=&gt; -4
</span><span class="w">
</span><span class="mi">9223372036854775807</span><span class="w">   </span><span class="c1">; java.lang.Long#MAX_VALUE
;;=&gt; 9223372036854775807
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Long
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mi">9223372036854775807</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Long
</span><span class="w">
</span><span class="mi">29384756298374652983746528376529837456</span><span class="w">
</span><span class="c1">;;=&gt; 29384756298374652983746528376529837456N
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mi">29384756298374652983746528376529837456</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.BigInt
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mi">1</span><span class="n">N</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.BigInt
</span><span class="w">
</span></code></pre>
</div>

<p>You can also define integers literals in other basis
such as octal, hexadecimals and binary.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="mi">127</span><span class="w"> </span><span class="c1">;;=&gt; 127              ; decimal
</span><span class="mi">0</span><span class="n">x7F</span><span class="w"> </span><span class="c1">;;=&gt; 127             ; hexadecimal
</span><span class="mi">0177</span><span class="w"> </span><span class="c1">;;=&gt; 127             ; octal
</span><span class="mi">32</span><span class="n">r3V</span><span class="w"> </span><span class="c1">;;=&gt; 127            ; base 32
</span><span class="mi">2</span><span class="n">r01111111</span><span class="w"> </span><span class="c1">;;=&gt; 127       ; binary
</span><span class="mi">36</span><span class="n">r3J</span><span class="w"> </span><span class="c1">;;=&gt; 127            ; base 36
</span><span class="w">
</span><span class="mi">36</span><span class="n">rClojure</span><span class="w"> </span><span class="c1">;;=&gt; 27432414842
</span><span class="mi">2</span><span class="n">r0111001101010001001001</span><span class="w"> </span><span class="c1">;;=&gt; 1889353
</span><span class="w">
</span></code></pre>
</div>

<p>In Clojure there are no operators, in fact <code class="highlighter-rouge">+</code>,
<code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">*</code> and <code class="highlighter-rouge">/</code> are normal functions.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 15
</span><span class="w">
</span></code></pre>
</div>

<p>You can access static fields by
providing the fully qualified class name
followed by a slash (<code class="highlighter-rouge">/</code>) and the field name,
for example: <code class="highlighter-rouge">java.lang.Long/MAX_VALUE</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="n">java.lang.Long/MAX_VALUE</span><span class="w">
</span><span class="c1">;;=&gt; 9223372036854775807
</span><span class="w">
</span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">java.lang.Long/MAX_VALUE</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 9223372036854775806
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">java.lang.Long/MAX_VALUE</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ArithmeticException integer overflow
</span><span class="w">

</span></code></pre>
</div>

<p>Clojure has a number of functions which will
automatically auto-promote the number to be
bigger type in case it doesn’t fit in the 64bit
Java Long object. These functions are: <code class="highlighter-rouge">+'</code>,
<code class="highlighter-rouge">-'</code> and <code class="highlighter-rouge">*'</code></p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="o">'</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">java.lang.Long/MAX_VALUE</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 9223372036854775808N
</span><span class="w">
</span><span class="p">(</span><span class="nb">*</span><span class="o">'</span><span class="w"> </span><span class="n">java.lang.Long/MAX_VALUE</span><span class="w"> </span><span class="n">java.lang.Long/MAX_VALUE</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 85070591730234615847396907784232501249N
</span><span class="w">

</span></code></pre>
</div>

<h4 id="decimals">Decimals</h4>

<p>Clojure supports floating point decimals and
exact decimals.  Floating point decimals are
mapped to <code class="highlighter-rouge">java.lang.Double</code> and they evaluate
to themselves. While exact decimals are mapped
to <code class="highlighter-rouge">java.math.BigDecimal</code> and they also
evaluate to themselves.  Use the latter when
you require exact decimals but be careful to
numbers which can’t be represented with exact
decimals like: 1 divided by 3 (0.3333333…) as
the the decimal part continue forever.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="mf">3.2</span><span class="w">
</span><span class="c1">;;=&gt; 3.2
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mf">3.2</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Double
</span><span class="w">
</span><span class="mf">3.2</span><span class="n">M</span><span class="w">
</span><span class="c1">;;=&gt; 3.2M
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mf">3.2</span><span class="n">M</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.math.BigDecimal
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mf">0.3</span><span class="w"> </span><span class="mf">0.3</span><span class="w"> </span><span class="mf">0.3</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="c1">;; floating point
;;=&gt; 0.9999999999999999
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mf">0.3</span><span class="n">M</span><span class="w"> </span><span class="mf">0.3</span><span class="n">M</span><span class="w"> </span><span class="mf">0.3</span><span class="n">M</span><span class="w"> </span><span class="mf">0.1</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="c1">;; big-decimal
;;=&gt; 1.0M
</span><span class="w">
</span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mf">1.0</span><span class="n">M</span><span class="w"> </span><span class="mf">3.0</span><span class="n">M</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ArithmeticException Non-terminating decimal expansion; no exact representable decimal result.
</span><span class="w">
</span><span class="p">(</span><span class="nf">with-precision</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mf">1.0</span><span class="n">M</span><span class="w"> </span><span class="mf">3.0</span><span class="n">M</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 0.3333333333M
</span><span class="w">
</span></code></pre>
</div>

<h4 id="rationals">Rationals</h4>

<p>Number like 1 divided by 3 are called rational
numbers, and Clojure supports them. You can mix
then in your calculation and as long as you
don’t put floating point values it will retain
the precision.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1/3
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.Ratio
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1N
</span><span class="w">
</span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 7/2
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 2N
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mi">1</span><span class="n">/3</span><span class="w"> </span><span class="mf">0.333</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 0.9996666666666667
</span><span class="w">

</span></code></pre>
</div>

<h3 id="characters">Characters</h3>

<p>So far we have seen the rich support for
numerical values in Clojure.  Clojure does
support characters and strings literals as
well.  Characters map to <code class="highlighter-rouge">java.lang.Character</code>,
support Unicode characters and as all
value-types they evaluate to themselves.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="sc">\a</span><span class="w">       </span><span class="c1">; this is the character 'a'
</span><span class="sc">\A</span><span class="w">       </span><span class="c1">; this is the character 'A'
</span><span class="sc">\\</span><span class="w">       </span><span class="c1">; this is the character '\'
</span><span class="sc">\u</span><span class="mi">0041</span><span class="w">   </span><span class="c1">; this is unicode for  'A'
</span><span class="sc">\t</span><span class="n">ab</span><span class="w">     </span><span class="c1">; this is the tab character
</span><span class="sc">\n</span><span class="n">ewline</span><span class="w"> </span><span class="c1">; this is the newline character
</span><span class="sc">\s</span><span class="n">pace</span><span class="w">   </span><span class="c1">; this is the space character
</span><span class="w">
</span><span class="sc">\a</span><span class="w"> </span><span class="c1">;;=&gt; \a
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="sc">\a</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Character
</span><span class="w">
</span></code></pre>
</div>

<h3 id="strings">Strings</h3>

<p>Strings literals have no surprise. They map to
<code class="highlighter-rouge">java.lang.String</code>, they are multi-line, like
in Java they are immutable and they evaluate to
themselves.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="s">"This is a string"</span><span class="w">
</span><span class="c1">;;=&gt; "This is a string"
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="s">"This is a string"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.String
</span><span class="w">
</span><span class="s">"Strings in Clojure
 can be multi lines
 as well!!"</span><span class="w">
</span><span class="c1">;;=&gt; "Strings in Clojure\n can be multi lines\n as well!!"
</span><span class="w">
</span></code></pre>
</div>

<p>Via the Java interop. infrastructure you can
call all <code class="highlighter-rouge">java.lang.String</code> methods directly</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">.toUpperCase</span><span class="w"> </span><span class="s">"This is a String"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "THIS IS A STRING"
</span><span class="w">
</span></code></pre>
</div>

<p>You can use the function <code class="highlighter-rouge">str</code> to concatenate
strings or to convert numbers into strings (via
<code class="highlighter-rouge">Object#toString()</code> method).</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"This"</span><span class="w"> </span><span class="s">" is "</span><span class="w"> </span><span class="s">"a"</span><span class="w"> </span><span class="s">" concatenation."</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "This is a concatenation."
</span><span class="w">
</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Number of lines: "</span><span class="w"> </span><span class="mi">123</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Number of lines: 123"
</span><span class="w">

</span></code></pre>
</div>

<h3 id="keywords">Keywords</h3>

<p>Keywords are labels for things in our programs,
they evaluate to themselves and can be used to
give name to things similarly to Java’s
enumerations.  They mostly used as key in maps
(we will see this later), and the Clojure
runtime maintains them in a internal pool
(similarly to interned strings in Java.)  which
guarantee that only one copy of a particular
keyword will ever exist in a program. For this
reason they provide very fast equality test.
Equality test in Clojure is done via the
function <code class="highlighter-rouge">=</code> with the same semantic as the
Java’s <code class="highlighter-rouge">.equals()</code> method, while the identity
equality is done via the function <code class="highlighter-rouge">identical?</code>
which in turn implements the Java’s <code class="highlighter-rouge">==</code>
operator.  You can use the function <code class="highlighter-rouge">keyword</code>
to create a keyword out of a string.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">

</span><span class="no">:words</span><span class="w">
</span><span class="c1">;;=&gt; :words
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="no">:this-is-a-keyword</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.Keyword
</span><span class="w">
</span><span class="p">(</span><span class="nb">keyword</span><span class="w"> </span><span class="s">"blue"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :blue
</span><span class="w">
</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:blue</span><span class="w"> </span><span class="no">:blue</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">identical?</span><span class="w"> </span><span class="no">:blue</span><span class="w"> </span><span class="no">:blue</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">identical?</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nb">identical?</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"bl"</span><span class="w"> </span><span class="s">"ue"</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span></code></pre>
</div>

<h3 id="collections">Collections</h3>

<p>In Java the only collection literals available
is the array.  Clojure like most modern
languages offers a variety of collection
literals which makes the language more
expressive. Out-of-the-box support is provided for
the following collections literals: single linked
lists, vectors, maps (or dictionaries) and
sets.  However Clojure supports a larger number
of data structures which are built with
functions such as: sorted maps, sorted sets,
array maps, hash maps and hash sets. Many more
data structures are available in community maintained
libraries such as graphs, ring buffers and AVL
trees. <strong>All Clojure collections can contain a
mixture of values</strong>.</p>

<h4 id="lists">Lists</h4>

<p>Clojure has single-linked lists built-in and
like all other Clojure collections are
immutable.  Lists guarantee <code class="highlighter-rouge">O(1)</code> insertion on
the head, <code class="highlighter-rouge">O(n)</code> traversal and element search.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="n">to</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">list</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">`</span><span class="nb">list</span><span class="o">`</span><span class="w">

</span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (1 2 3 4 5)
</span><span class="w">
</span></code></pre>
</div>
<p>to “add” an element on the front of the list you can
use the <code class="highlighter-rouge">cons</code> function.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (0 1 2 3 4 5)
</span><span class="w">
</span></code></pre>
</div>
<p>As the output suggest the lists literals in
Clojure are expressed with a sequence of values
surrounded by brackets, which is the same of
the function call. That is the reason why the
following line throws an error.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn
</span><span class="w">
</span></code></pre>
</div>
<p>To be able to express a list of values as a
literal we have to used the <code class="highlighter-rouge">quote</code> form which
it will preserve the list without initiate the
function call.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">quote</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (1 2 3 4 5)
</span><span class="w">
</span></code></pre>
</div>

<p>As syntax sugar we can use the single quote
sign <code class="highlighter-rouge">'</code> instead of the longer <code class="highlighter-rouge">(quote ,,,)</code>
form.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (1 2 3 4 5)
</span><span class="w">
</span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="s">"hi"</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="mi">4</span><span class="n">/5</span><span class="w"> </span><span class="sc">\c</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (1 "hi" :test 4/5 \c)
</span><span class="w">
</span></code></pre>
</div>

<p>you can get the head of the list with the
function <code class="highlighter-rouge">first</code> and use <code class="highlighter-rouge">rest</code> or <code class="highlighter-rouge">next</code> to
get the tail. <code class="highlighter-rouge">count</code> returns the number of
elements in it. <code class="highlighter-rouge">nth</code> returns the nth element
of the list, while <code class="highlighter-rouge">last</code> returns last item in
the list.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (2 3 4 5)
</span><span class="w">
</span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (2 3 4 5)
</span><span class="w">
</span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; ()
</span><span class="w">
</span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 5
</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 2
</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; IndexOutOfBoundsException
</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:not-found</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :not-found
</span><span class="w">
</span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 5
</span><span class="w">
</span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="o">'</span><span class="p">())</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span></code></pre>
</div>

<h4 id="vectors">Vectors</h4>

<p>Vectors are collections of values which are
indexed by their position in the vector
(starting from 0) called <strong>index</strong>. Insertion
at the end of the vector is <code class="highlighter-rouge">near O(1)</code> as well
as retrieval of an element by it’s index.  The
literals is expressed with a sequence of values
surrounded by square brackets or you can use
the <code class="highlighter-rouge">vector</code> function to construct one.  You
can append an element at the end of the vector
with <code class="highlighter-rouge">conj</code> and use <code class="highlighter-rouge">get</code> to retrieve an
element in a specific index. Function such as
<code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">next</code> <code class="highlighter-rouge">rest</code>, <code class="highlighter-rouge">last</code> and <code class="highlighter-rouge">count</code> will
work just as fine with Vectors.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
</span><span class="c1">;;=&gt; [1 2 3 4 5]
</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="s">"hi"</span><span class="w"> </span><span class="no">:test</span><span class="w"> </span><span class="mi">4</span><span class="n">/5</span><span class="w"> </span><span class="sc">\c</span><span class="p">]</span><span class="w">
</span><span class="c1">;;=&gt; [1 "hi" :test 4/5 \c]
</span><span class="w">
</span><span class="p">(</span><span class="nb">vector</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; [1 2 3 4 5]
</span><span class="w">
</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; [1 2 3 4 5 6]
</span><span class="w">
</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; 2
</span><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; :a
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :b
</span><span class="w">
</span><span class="p">([</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :b
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:z</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :z
</span><span class="w">
</span></code></pre>
</div>

<p>One important thing to note is that Clojure’s
data-structures are persistent which has
anything to do with the durability (like: disk
persistence). Persistent data structure do have
structural sharing.  To understand more about
this you can read the following blog post:
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">Understanding Clojure’s Persistent</a></p>

<h4 id="maps">Maps</h4>

<p>Maps are associative data structures (often
called dictionaries) which maps keys to their
corresponding value.  Maps have a literal form
which can be expressed by any number of
key/value pairs surrounded by curly brackets,
or by using <code class="highlighter-rouge">hash-map</code> or <code class="highlighter-rouge">array-map</code>
functions. Hash-maps provides a <code class="highlighter-rouge">near O(1)</code>
insertion time and <code class="highlighter-rouge">near O(1)</code> seek time.  You
can use <code class="highlighter-rouge">assoc</code> to “add or overwrite” an new
pair, <code class="highlighter-rouge">dissoc</code> to “remove” a key and its value,
and use <code class="highlighter-rouge">get</code> to retrieve the value of a given
key.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">{</span><span class="s">"jane"</span><span class="w"> </span><span class="s">"jane@acme.com"</span><span class="w">
 </span><span class="s">"fred"</span><span class="w"> </span><span class="s">"fred@acme.com"</span><span class="w">
 </span><span class="s">"rob"</span><span class="w">  </span><span class="s">"rob@acme.com"</span><span class="p">}</span><span class="w">
</span><span class="c1">;;=&gt; {"jane" "jane@acme.com", "fred" "fred@acme.com", "rob" "rob@acme.com"}
</span><span class="w">
</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 2, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">hash-map</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; {:c 3, :b 2, :a 1}
</span><span class="w">
</span><span class="p">(</span><span class="nb">array-map</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 2, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 2, :c 3, :d 4}
</span><span class="w">
</span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 10, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; 3
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="no">:not-found</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:ZULU</span><span class="w"> </span><span class="no">:not-found</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; :not-found
</span><span class="w">
</span><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">({</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span></code></pre>
</div>

<h4 id="sets">Sets</h4>

<p>Sets are a type of collection which doesn’t
allow for duplicate values.  While lists and
vector can have duplicate elements, set
eliminates all duplicates.  Clojure has a
literal form for sets which is expressed by a
sequence of values surrounded by <code class="highlighter-rouge">#{
}</code>. Otherwise you construct a set using the
<code class="highlighter-rouge">set</code> function.  With <code class="highlighter-rouge">conj</code> you can “add” a
new element to an existing set, and <code class="highlighter-rouge">disj</code> to
“remove” an element from the set.  With
<code class="highlighter-rouge">clojure.set/union</code>, <code class="highlighter-rouge">clojure.set/difference</code>
and <code class="highlighter-rouge">clojure.set/intersection</code> you have typical
sets operations.  <code class="highlighter-rouge">count</code> returns the number of
elements in the set in <code class="highlighter-rouge">O(1)</code> time.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w">
</span><span class="c1">;;=&gt; #{1 4 2}
</span><span class="w">
</span></code></pre>
</div>

<p>If you put twice the same element
your Clojure code will be syntactically
incorrect. At the REPL you will get
an error.</p>

<p>#{ 1 1 3 5}
;;=&gt; IllegalArgumentException Duplicate key: 1</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="s">"hello"</span><span class="p">}</span><span class="w">
</span><span class="c1">;;=&gt; #{"hello" 4 5 :d :a}
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:z</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.PersistentHashSet
</span><span class="w">
</span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; #{:c :b :a}
</span><span class="w">
</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:c</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #{:c :b :a}
</span><span class="w">
</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:c</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #{:c :a}
</span><span class="w">
</span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">}</span><span class="w"> </span><span class="no">:b</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #{:c :a}
</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.set/union</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:c</span><span class="w"> </span><span class="no">:a</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; #{:c :b :a}
</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.set/difference</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:c</span><span class="w"> </span><span class="no">:a</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; #{:b}
</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.set/intersection</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:c</span><span class="w"> </span><span class="no">:a</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; #{:a}
</span><span class="w">

</span></code></pre>
</div>

<h3 id="the-sequence-abstraction">The sequence abstraction</h3>

<p>One of the most powerful abstraction of
Clojure’s data structures is the <code class="highlighter-rouge">sequence</code>
(<code class="highlighter-rouge">clojure.lang.ISeq</code>) which all data structure
implements. This interface resembles to a Java
iterator, and it implements methods like
<code class="highlighter-rouge">first()</code>, <code class="highlighter-rouge">rest()</code>, <code class="highlighter-rouge">more()</code> and <code class="highlighter-rouge">cons()</code>. The
power of this abstraction is that it is general
enough to be used in all data structures
(lists, vectors, maps, sets and even strings
can all produce sequences) and you have loads
of functions which manipulates it. Functions
such as <code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">rest</code>, <code class="highlighter-rouge">next</code> and <code class="highlighter-rouge">last</code> and
many others such as <code class="highlighter-rouge">reverse</code>, <code class="highlighter-rouge">shuffle</code>,
<code class="highlighter-rouge">drop</code>, <code class="highlighter-rouge">take</code>, <code class="highlighter-rouge">partition</code>, <code class="highlighter-rouge">filter</code> etc are
all built on top of the sequence abstraction.
So if you create your own data-structure and
you implement the four methods of the
<code class="highlighter-rouge">clojure.lang.ISeq</code> interface you can benefit
from all these function without having to
re-implement them for your specific
data-structure.</p>

<p>You can create a sequence explicitly with the
<code class="highlighter-rouge">seq</code> function but there are loads of functions
which already return a sequence. The sequence
of a list is the list itself, other
data-structures will produce one.  Maps will
produce a sequence of map entries, where each
entry can be represented like a vector of two
values (the key and it’s value.)</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (1 2 3 4)
</span><span class="w">
</span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (1 2 3 4)
</span><span class="w">
</span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; (1 4 3 2)
</span><span class="w">
</span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; ([:a 1] [:b 2] [:c 3])
</span><span class="w">
</span></code></pre>
</div>

<p>There is no need to call <code class="highlighter-rouge">seq</code> explicitly, in
most of the cases, functions which take a
sequence can work with all data structures
directly.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (:a :b :c)
</span><span class="w">
</span><span class="p">(</span><span class="nf">shuffle</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; [1 3 2 4]
</span><span class="w">
</span><span class="p">(</span><span class="nf">shuffle</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; [2 4 1 3]
</span><span class="w">
</span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (4 3 2 1)
</span><span class="w">
</span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w">
</span><span class="c1">;;=&gt; [:a 1]
</span><span class="w">
</span></code></pre>
</div>

<p>Because the Clojure String implements the sequence
abstraction, you can treat the String as a sequence
of characters.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"Hello World!"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (\H \e \l \l \o \space \W \o \r \l \d \!)
</span><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; \H
</span><span class="w">
</span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="s">"Hello"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (\e \l \l \o)
</span><span class="w">
</span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="s">"Hello World!"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 12
</span><span class="w">
</span></code></pre>
</div>

<h4 id="lazy-sequences">Lazy Sequences</h4>

<p>Some of the sequences produced by the core
library are lazy which means that the entire
collection won’t be created (<em>realised</em>) all at
once.  At first, an iterator like structure is
created, with subsequent calls to <code class="highlighter-rouge">next()</code>
causing chunks of items to be
fetched/computed. This is a very important
element of the language which allows the easy
expression of infinite sequences without
running out of memory. For example the function
<code class="highlighter-rouge">range</code> returns a lazy sequence of natural
numbers between two given numbers. But when it
is called without arguments it returns a lazy
sequence of all natural numbers.  Yet it
doesn’t run out of memory. What it really
produces is just an iterator that computes the
next chunk of numbers when <code class="highlighter-rouge">next()</code> is called.</p>

<p><em>NOTE: As subsequent calls are made to
<code class="highlighter-rouge">next()</code>, it is advisable not to reference/hold
earlier lazy sequence items for too long. This
allows earlier items to be cleared from memory
and prevents OOM (OutOfMemoryError).</em></p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (5 6 7 8 9)
</span><span class="w">
</span></code></pre>
</div>
<p><em><strong>WARNING!!!</strong> Evaluating this from your REPL
might hang/crash your process</em>, as it will try
evaluate an infinite lazy sequence all at once.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 ...)
</span><span class="w">
</span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (0 1 2 3 4 5 6 7 8 9)
</span><span class="w">
</span></code></pre>
</div>

<h3 id="regular-expression-patterns">Regular expression patterns</h3>

<p>Clojure also supports regular expression
patterns as literals which directly map to the
<code class="highlighter-rouge">java.util.Pattern</code> and offers a number of
functions to match, find and extract patterns.
For example: <code class="highlighter-rouge">re-find</code> and <code class="highlighter-rouge">re-seq</code> to find
respectively the first or all occurrences of a
matching pattern. With <code class="highlighter-rouge">re-pattern</code> you can
programmatically create a function out of a
string.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="o">#</span><span class="s">"[\w\d.-]+@[\w\d-.]+\.[\w]+"</span><span class="w">
</span><span class="c1">;;=&gt; #"[\w\d.-]+@[\w\d-.]+\.[\w]+"
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="o">#</span><span class="s">"[\w\d.-]+@[\w\d-.]+\.[\w]+"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.util.regex.Pattern
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"[0-9]+"</span><span class="w"> </span><span class="s">"only 123 numbers"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "123"
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"[0-9]+"</span><span class="w"> </span><span class="s">"no numbers"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"[\w\d.-]+@[\w\d-.]+\.[\w]+"</span><span class="w">
         </span><span class="s">"bob.smith@acme.org"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "bob.smith@acme.org"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"^[\w\d.-]+@[\w\d-.]+\.[\w]+$"</span><span class="w">
             </span><span class="s">"bob.smith@acme.org"</span><span class="p">)</span><span class="w">
  </span><span class="s">"it's an email"</span><span class="w">
  </span><span class="s">"it's not an email"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "it's an email"
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-seq</span><span class="w"> </span><span class="o">#</span><span class="s">"[0-9]+"</span><span class="w"> </span><span class="s">"25, 43, 54, 12, 15, 65"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ("25" "43" "54" "12" "15" "65")
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-pattern</span><span class="w"> </span><span class="s">"[0-9]{1,3}(\\.[0-9]{1,3}){3}"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #"[0-9]{1,3}(\.[0-9]{1,3}){3}"
</span><span class="w">
</span><span class="p">(</span><span class="nb">re-find</span><span class="w">
 </span><span class="p">(</span><span class="nb">re-pattern</span><span class="w"> </span><span class="s">"[0-9]{1,3}(\\.[0-9]{1,3}){3}"</span><span class="p">)</span><span class="w">
 </span><span class="s">"my IP is: 192.168.0.12"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ["192.168.0.12" ".12"]
</span><span class="w">
</span></code></pre>
</div>

<p>Using <code class="highlighter-rouge">re-matcher</code>, <code class="highlighter-rouge">re-matches</code>, <code class="highlighter-rouge">re-groups</code>
allows you to have fine control over the capturing
groups.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">

</span></code></pre>
</div>

<h3 id="symbols-and-vars">Symbols and Vars</h3>

<p>Symbols in Clojure are a way to identify things
in your programs which may have various values
at runtime. Like in a mathematical notation, <code class="highlighter-rouge">x</code>
is something not known which could assume
several different values.  In a programming
context, Clojure symbols are similar to
variables in other languages but not exactly.
In other languages variables are places where
you store information, symbols in Clojure
cannot contain data themselves.  Vars in
Clojure are the containers of data (one type
of), and symbols are a way to identify them and
give vars meaningful names for your program.</p>

<p>Everything we have seen so far were pure
values, as such they were all evaluating to
themselves.  Like <code class="highlighter-rouge">42</code> is just <code class="highlighter-rouge">42</code>, the
following vector <code class="highlighter-rouge">[:a "hello" 9]</code> just
evaluates to itself, it is just a value.
Symbols, however, during the evaluation
are replaced with the current value of var
they are pointing to. If you try to evaluate
a var which is undefined you will get an error.</p>

<p>Symbols are organised into namespaces.  We will
not explore much about namespaces here, but it
will suffice to know that symbols belong to a
namespace in which they assume a particular
value, and you can have the same symbol name in
different namesapce pointing to different
values.</p>

<p>In Clojure symbols start with a letter, and can
contain letters, numbers, dashes, some
punctuation marks and other
characters. Basically anything which doesn’t
belong in the Clojure syntax (following
characters aren’t accepted in symbols name
<code class="highlighter-rouge">@#,/.[]{}()</code>) anything else is a valid symbol.</p>

<p>You can create symbols by quoting a word with
the <code class="highlighter-rouge">quote</code> function or the single quote
character, you can use the function <code class="highlighter-rouge">symbol</code>,
but most commonly you will use symbols in place
of vars and locals which are define with the
special forms <code class="highlighter-rouge">def</code> and <code class="highlighter-rouge">let</code> respectively. A
symbol name which is NOT quoted will be
resolved to the current value of the associated
var.</p>

<p>As we will see in the following examples symbols
are un-typed and can refer to any Clojure value,
including <code class="highlighter-rouge">nil</code></p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">symbol</span><span class="w"> </span><span class="s">"username"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; username
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol</span><span class="w"> </span><span class="s">"username"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.Symbol
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'username</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.Symbol
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="s">"bruno1"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/username
</span><span class="w">
</span><span class="n">username</span><span class="w">
</span><span class="c1">;;=&gt; "bruno1"
</span><span class="w">
</span><span class="n">age</span><span class="w"> </span><span class="c1">;; undefined var produces error
;;=&gt; Unable to resolve symbol: age in this context
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="mi">21</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/age
</span><span class="w">
</span><span class="n">age</span><span class="w">
</span><span class="c1">;;=&gt; 21
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'age</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; clojure.lang.Symbol
</span><span class="w">
</span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; java.lang.Long
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"bruno1"</span><span class="w">
           </span><span class="no">:score</span><span class="w">    </span><span class="mi">12345</span><span class="w">
           </span><span class="no">:level</span><span class="w">    </span><span class="mi">32</span><span class="w">
           </span><span class="no">:achievements</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="no">:fast-run</span><span class="w"> </span><span class="no">:precision10</span><span class="w">
                           </span><span class="no">:strategy</span><span class="p">}})</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/user
</span><span class="w">
</span><span class="n">user</span><span class="w">
</span><span class="c1">;;=&gt; {:username "bruno1", :score 12345, :level 32, :achievements #{:precision10 :strategy :fast-run}}
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/user
</span><span class="w">
</span><span class="n">user</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">

</span></code></pre>
</div>

<h3 id="immutability">Immutability</h3>

<p>All basics data-types in Clojure are immutable,
including the collections. This is a very
important aspect of Clojure approach to
functional programming.  In Clojure functions
transform values into new values and values are
just values. Since it is absurd to think of
changing a number (1 is always 1),
composite data structures are treated in the same way.
So functions do not mutate values they just produce new ones.
Like adding <code class="highlighter-rouge">1</code> to <code class="highlighter-rouge">42</code> produces <code class="highlighter-rouge">43</code> but
doesn’t really change the number <code class="highlighter-rouge">42</code> as it keeps on
existing on its own, adding an element to a list will
produce a new list but the old one will still be same
and unmodified.</p>

<p>The advantage of the immutability is that
values (even deeply nested and complex
structures) can be safely shared across threads
and with function callers without worrying
about unsafe or uncoordinated changes.  This
simple constraint makes Clojure programs so
much easier to reason about, as the only way to
produce a new value is via a functional
transformation.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">colours</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="no">:red</span><span class="w"> </span><span class="no">:green</span><span class="w"> </span><span class="no">:blue</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/colours
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">new-colours</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="no">:black</span><span class="w"> </span><span class="n">colours</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/new-colours
</span><span class="w">
</span><span class="n">new-colours</span><span class="w">
</span><span class="c1">;;=&gt; (:black :red :green :blue)
</span><span class="w">
</span><span class="n">colours</span><span class="w">
</span><span class="c1">;;=&gt; (:red :green :blue)
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">{</span><span class="no">:username</span><span class="w"> </span><span class="s">"bruno1"</span><span class="w">
           </span><span class="no">:score</span><span class="w">    </span><span class="mi">12345</span><span class="w">
           </span><span class="no">:level</span><span class="w">    </span><span class="mi">32</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/user
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="o">'</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="no">:level</span><span class="w"> </span><span class="mi">33</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/user'
</span><span class="w">
</span><span class="n">user</span><span class="o">'</span><span class="w">
</span><span class="c1">;;=&gt; {:username "bruno1", :score 12345, :level 33}
</span><span class="w">
</span><span class="n">user</span><span class="w">
</span><span class="c1">;;=&gt; {:username "bruno1", :score 12345, :level 32}
</span><span class="w">
</span></code></pre>
</div>

<h3 id="functions">Functions</h3>

<p>So far we have seen how to represent data in
our system, now we will see how to make sense
of this data and how to
extract/process/transform it.  The way we
express this in Clojure is via functions.</p>

<h4 id="purity">Purity</h4>

<p>While Clojure doesn’t enforce purity at
compiler level, it certainly promotes
pure-functions.  Pure functions are those
functions in which the processing doesn’t use
or produce any side effect, which means it will
use only the input parameters to compute the
resulting value, and given the same parameters
it will always produce the same result.</p>

<p>When a function given a certain input, always
produces the same output it is said to be
<strong>referentially transparent</strong>, because the
function call itself can be replaced with
its value without altering the rest of the
expression.</p>

<p>Pure functions are important because
they are incredibly easy to test as
they don’t depend on external state.</p>

<p>Here are two examples: the first is the function <code class="highlighter-rouge">+</code>
which we have already seen, and the second is the
function <code class="highlighter-rouge">rand-int</code> which produce a random
integer number between <code class="highlighter-rouge">0</code> and the given
integer.  While the first is pure because given
the same input parameters it will always produce the
same output, the second one given the same
input returns a different value every time.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 6
</span><span class="w">
</span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 18
</span><span class="w">
</span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 85
</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="c1">;; (+ 1 1 1) is referentially transparent
;;=&gt; 6
</span><span class="w">
</span></code></pre>
</div>

<h4 id="function-definition">Function definition</h4>

<p>To define a function you have to use the
special form <code class="highlighter-rouge">fn</code> or <code class="highlighter-rouge">defn</code> with the following
syntax.</p>

<p>for example if we want to define a function
which increments the input parameters by 1 you
will write something as follow:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  /- fn, special form
 /  parameter vector, 1 param called `n`
 |  |  body -&gt; expression to evaluate when
 |  |  |       this function is called
(fn [n] (+ n 1))
</code></pre>
</div>

<p>This is the simplest way to define a function.</p>

<p>Now to refer to this function in our code we
need to give it a name. We can do so with <code class="highlighter-rouge">def</code>
as we done earlier.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">plus-one</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/plus-one
</span><span class="w">
</span><span class="p">(</span><span class="nf">plus-one</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 11
</span><span class="w">
</span><span class="p">(</span><span class="nf">plus-one</span><span class="w"> </span><span class="mi">-42</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; -41
</span><span class="w">
</span></code></pre>
</div>

<p>As mentioned earlier, during the evaluation process
the symbol <code class="highlighter-rouge">plus-one</code> is simply replaced with
its value, in the same way we can replace the
symbol with the function definition and obtain
the same result.  So symbols can also refer to
functions.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">((</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 11
</span><span class="w">
</span><span class="p">((</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">-42</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; -41
</span><span class="w">
</span></code></pre>
</div>

<p>Since defining functions is very common, there
is a shorthand to the idiom <code class="highlighter-rouge">(def funciton-name
(fn [parameter list] (expression)))</code> via the
<code class="highlighter-rouge">defn</code> form which just combines the <code class="highlighter-rouge">def</code> and
<code class="highlighter-rouge">fn</code> forms.  So we can redefine the previous
function in the following way:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">plus-one</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/plus-one
</span><span class="w">
</span><span class="p">(</span><span class="nf">plus-one</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 2
</span><span class="w">
</span></code></pre>
</div>

<p>It is good practice to include a short description (called <code class="highlighter-rouge">docstring</code>)
in the function.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">plus-one</span><span class="w">
  </span><span class="s">"Returns a number which is one greater than the given `n`."</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/plus-one
</span><span class="w">
</span></code></pre>
</div>

<p><strong>NOTE:</strong> that Clojure core already contains
such a function and it is called <code class="highlighter-rouge">inc</code>, while the
function <code class="highlighter-rouge">dec</code> decrements by 1 the given value.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 11
</span><span class="w">

</span></code></pre>
</div>

<p>In the following example we see how to create
functions with multiple parameters.  Let’s
assume we have to create a function which
create a corporate email address for its
employee. Oftentimes this type of email follows
a very specific pattern In this case we will
take the first letter of the name followed by
the lastname then <code class="highlighter-rouge">@</code> the company domain.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">email-address</span><span class="w"> </span><span class="p">[</span><span class="n">firstname</span><span class="w"> </span><span class="n">lastname</span><span class="w"> </span><span class="n">domain</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/lower-case</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">firstname</span><span class="p">)</span><span class="w"> </span><span class="n">lastname</span><span class="w"> </span><span class="s">"@"</span><span class="w"> </span><span class="n">domain</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/email-address
</span><span class="w">
</span><span class="p">(</span><span class="nf">email-address</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Smith"</span><span class="w"> </span><span class="s">"acme.org"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "jsmith@acme.org"
</span><span class="w">
</span><span class="p">(</span><span class="nf">email-address</span><span class="w"> </span><span class="s">"Walter"</span><span class="w"> </span><span class="s">"White"</span><span class="w"> </span><span class="s">"breakingbad.org"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "wwhite@breakingbad.org"
</span><span class="w">
</span></code></pre>
</div>

<h4 id="function-with-multi-arities">Function with multi-arities</h4>

<p>So far we’ve seen how to create functions
which accept a fix number of parameters.
In Clojure is possible to create functions
which accept different set of ‘arities’.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">simple-greet</span><span class="w">
  </span><span class="p">([]</span><span class="w">
   </span><span class="p">(</span><span class="nf">simple-greet</span><span class="w"> </span><span class="s">"World"</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="nb">name</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello "</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="s">"!"</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/simple-greet
</span><span class="w">
</span><span class="p">(</span><span class="nf">simple-greet</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hello World!"
</span><span class="w">
</span><span class="p">(</span><span class="nf">simple-greet</span><span class="w"> </span><span class="s">"Fred"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hello Fred!"
</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">greet</span><span class="w">
  </span><span class="p">([]</span><span class="w">
   </span><span class="s">"Hey, Stranger!"</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="nb">name</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello "</span><span class="w"> </span><span class="nb">name</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">firstname</span><span class="w"> </span><span class="n">lastname</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hi, you must be: "</span><span class="w"> </span><span class="n">lastname</span><span class="w"> </span><span class="s">", "</span><span class="w"> </span><span class="n">firstname</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="n">lastname</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">title</span><span class="w"> </span><span class="n">firstname</span><span class="w"> </span><span class="n">lastname</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello "</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="n">firstname</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="n">lastname</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/greet
</span><span class="w">
</span><span class="p">(</span><span class="nf">greet</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hey, Stranger!"
</span><span class="w">
</span><span class="p">(</span><span class="nf">greet</span><span class="w"> </span><span class="s">"James"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hello James"
</span><span class="w">
</span><span class="p">(</span><span class="nf">greet</span><span class="w"> </span><span class="s">"James"</span><span class="w"> </span><span class="s">"Bond"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hi, you must be: Bond, James Bond"
</span><span class="w">
</span><span class="p">(</span><span class="nf">greet</span><span class="w"> </span><span class="s">"Dr"</span><span class="w"> </span><span class="s">"John H."</span><span class="w"> </span><span class="s">"Watson"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Hello Dr John H. Watson"
</span><span class="w">

</span></code></pre>
</div>

<p>It is also possible to create functions
which have any number of parameters.
these are called <code class="highlighter-rouge">variadic functions</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">de-dup</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">names</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">names</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/de-dup
</span><span class="w">
</span><span class="p">(</span><span class="nf">de-dup</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Fred"</span><span class="w"> </span><span class="s">"Lara"</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"John"</span><span class="w"> </span><span class="s">"Susan"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ("Susan" "Fred" "John" "Lara")
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">short-name</span><span class="w"> </span><span class="p">[</span><span class="n">firstname</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">names</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">firstname</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">names</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/short-name
</span><span class="w">
</span><span class="p">(</span><span class="nf">short-name</span><span class="w"> </span><span class="s">"Maria"</span><span class="w"> </span><span class="s">"Teresa"</span><span class="w"> </span><span class="s">"Jiulia"</span><span class="w"> </span><span class="s">"Ramírez de Arroyo"</span><span class="w"> </span><span class="s">"García"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Maria García"
</span><span class="w">
</span></code></pre>
</div>

<h4 id="high-order-functions">High-order functions</h4>

<p>In Clojure functions are reified contructs,
therefore we can threat them as normal
values. As such functions can be passed as
parameters of function or returned as result of
function call.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-commutative?</span><span class="w"> </span><span class="p">[</span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">op</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/is-commutative?
</span><span class="w">
</span><span class="p">(</span><span class="nf">is-commutative?</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nf">is-commutative?</span><span class="w"> </span><span class="nb">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/multiplier
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="p">(</span><span class="nf">multiplier</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/doubler
</span><span class="w">
</span><span class="p">(</span><span class="nf">doubler</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 10
</span><span class="w">
</span><span class="p">(</span><span class="nf">doubler</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 20
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mult-10x</span><span class="w"> </span><span class="p">(</span><span class="nf">multiplier</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/mult-10x
</span><span class="w">
</span><span class="p">(</span><span class="nf">mult-10x</span><span class="w"> </span><span class="mi">35</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 350
</span><span class="w">
</span></code></pre>
</div>

<h4 id="anonymous-functions-or-lambda-functions">Anonymous functions or lambda functions</h4>

<p>Oftentimes you want to create a function for a
specific task in a local context. Such
functions don’t have any reason to have a
global name as they are meaningful only in that
specific context, in this case you can create
anonymous functions (also called lambda
function) and Clojure has some support to make
this easier.  We already seen an example of an
anonymous function with our very first function
example.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="c1">;;Evaluates to an object/value. In Clojure, functions are values
;;=&gt; #function[learn-clojure.basics/eval20002/fn--20003]
</span><span class="w">
</span><span class="p">((</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 11
</span><span class="w">
</span></code></pre>
</div>

<p>here the function we built hasn’t got a name.
We then used a <code class="highlighter-rouge">def</code> form to give it the
<code class="highlighter-rouge">plus-one</code> name.
This anonymous function could also be written
in the following way.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #function[learn-clojure.basics/eval20028/fn--20029]
</span><span class="w">
</span><span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 11
</span><span class="w">
</span></code></pre>
</div>

<p>In this function the symbol <code class="highlighter-rouge">%</code> replace the argument
If you have more than one parameter you can denote them as
<code class="highlighter-rouge">%1</code> (or <code class="highlighter-rouge">%</code>), <code class="highlighter-rouge">%2</code>, <code class="highlighter-rouge">%3</code>, <code class="highlighter-rouge">%4</code> …</p>

<p>for example in our <code class="highlighter-rouge">is-commutative?</code> function we expect
and operation which accept two arguments:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">is-commutative?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="n">%2</span><span class="p">)</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span></code></pre>
</div>

<h4 id="closures">Closures</h4>

<p>Closures (with the <code class="highlighter-rouge">s</code>) are lambdas which refer
to a context (or values from another context).
These functions are said to be “closing over”
the environment. This means that it can access
parameters and values which are NOT in the
parameters list.</p>

<p>Like in our <code class="highlighter-rouge">multiplier</code> function example, the
returned function is closing over the value <code class="highlighter-rouge">m</code>
which is not in its parameter list but it is a
parameter of the parent context the
<code class="highlighter-rouge">multiplier</code> fn. While <code class="highlighter-rouge">n</code> is a normal
parameter <code class="highlighter-rouge">m</code> is the value we are “closing
over” providing a context for that function.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/multiplier
</span><span class="w">
</span></code></pre>
</div>

<p>Let’s see another example. Here we want to
create a function which takes a number and
return a logical value representing whether the
number is between two limits (limits included).
For this purpose we can use the function <code class="highlighter-rouge">&gt;=</code>
which returns whether a number is greater or
equal then the other one.</p>

<p>Other similar functions are <code class="highlighter-rouge">&gt;</code>, <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">=</code> and <code class="highlighter-rouge">not=</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;; like 10 &gt;= 3
;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">limit-checker</span><span class="w"> </span><span class="p">[</span><span class="nb">min</span><span class="w"> </span><span class="nb">max</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="nb">min</span><span class="p">)))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/limit-checker
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">legal-value</span><span class="w"> </span><span class="p">(</span><span class="nf">limit-checker</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/legal-value
</span><span class="w">
</span><span class="p">(</span><span class="nf">legal-value</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">
</span><span class="p">(</span><span class="nf">legal-value</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nf">legal-value</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nf">legal-value</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; false
</span><span class="w">
</span></code></pre>
</div>

<h4 id="recursion">Recursion</h4>

<p>A recursive function is a function which
calls itself. There are two types of recursion
the mundane recursion and the tail recursion.</p>

<p>Let’s see an example of both with this function
which given a number it calculates the sum of
all natural numbers from 1 to the given
number.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sum1</span><span class="w">
  </span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">n</span><span class="w"> </span><span class="n">accumulator</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
     </span><span class="n">accumulator</span><span class="w">
     </span><span class="c1">;; else
</span><span class="w">     </span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)))))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/sum1
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 6
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 55
</span><span class="w">
</span></code></pre>
</div>

<p>This type of recursion is called mundane
recursion and every new call it allocates one
new frame on the stack so if you run this with
high enough numbers it will blow your stack.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">sum1</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; StackOverflowError
</span><span class="w">
</span></code></pre>
</div>

<p>Let’s see how we can write this
function with a tail recursion using
<code class="highlighter-rouge">recur</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sum2</span><span class="w">
  </span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">sum2</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">n</span><span class="w"> </span><span class="n">accumulator</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
     </span><span class="n">accumulator</span><span class="w">
     </span><span class="c1">;; else
</span><span class="w">     </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)))))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/sum2
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum2</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 55
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum2</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 50005000
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum2</span><span class="w"> </span><span class="mi">1000000</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 500000500000
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum2</span><span class="w"> </span><span class="mi">100000000</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 5000000050000000
</span><span class="w">
</span></code></pre>
</div>

<p>As you can see the function can recur much
more without exploding this is because
it doesn’t consume stack.
The tail recursion can be used only when
when the recursion point is in the tail
position (a return position).</p>

<p>Now in <code class="highlighter-rouge">sum1</code> and <code class="highlighter-rouge">sum2</code> we had to add
another function arity just to keep track
of the <code class="highlighter-rouge">accumulator</code>. This is very
common in recursion, while recurring
you have to keep track of some
accumulated value, therefore Clojure
makes it simpler by providing another
form called <code class="highlighter-rouge">loop</code> which plays well
with <code class="highlighter-rouge">recur</code>. In Clojure you’ll often
hear about <code class="highlighter-rouge">loop/recur</code> construct.</p>

<p>Let’s see how we can rewrite the previous
function to leverage the <code class="highlighter-rouge">loop/recur</code>
construct.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sum3</span><span class="w">
  </span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w">           </span><span class="n">num</span><span class="w">
         </span><span class="n">accumulator</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
      </span><span class="n">accumulator</span><span class="w">
      </span><span class="c1">;; else
</span><span class="w">      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">accumulator</span><span class="p">)))))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/sum3
</span><span class="w">
</span><span class="p">(</span><span class="nf">sum3</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 55
</span><span class="w">
</span></code></pre>
</div>
<p>Let’s see another example with the Fibonacci
sequence. Let’s start with the mundane
recursion.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fibonacci1</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="mi">1</span><span class="w">
    </span><span class="c1">;; else
</span><span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">fibonacci1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nf">fibonacci1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/fibonacci1
</span><span class="w">
</span><span class="p">(</span><span class="nf">fibonacci1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span><span class="p">(</span><span class="nf">fibonacci1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 89
</span><span class="w">

</span></code></pre>
</div>

<p>Now this is a simple and very functional
definition of the Fibonacci sequence, however
it is particularly bad in terms of computational
complexity.  in fact this is <code class="highlighter-rouge">O(2^n)</code>.
Let’s use the <code class="highlighter-rouge">time</code> function to
calculate how much it takes to compute the
35th number in the sequence.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nf">fibonacci1</span><span class="w"> </span><span class="mi">35</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "Elapsed time: 1806.753129 msecs"
;;=&gt; 14930352
</span><span class="w">
</span></code></pre>
</div>

<p>Let’s try to use tail recursion.
As you will see we have to restructure
our function to allow the recursion
to happen in the tail position.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fibonacci2</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
      </span><span class="n">c</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="o">'</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))))</span><span class="w">
</span><span class="c1">;;=&gt; #'learn-clojure.basics/fibonacci2
</span><span class="w">
</span><span class="p">(</span><span class="nf">fibonacci2</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 89
</span><span class="w">
</span><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nf">fibonacci2</span><span class="w"> </span><span class="mi">35</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "Elapsed time: 0.04467 msecs"
;;=&gt; 14930352
</span><span class="w">
</span><span class="p">(</span><span class="nb">time</span><span class="w">
 </span><span class="p">(</span><span class="nf">fibonacci2</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "Elapsed time: 1.145227 msecs"
;;=&gt; 70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501N
</span><span class="w">

</span></code></pre>
</div>

<h4 id="function-composition-and-partial-functions">Function composition and partial functions</h4>

<p>We have seen earlier that there are functions
such as <code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">second</code>, <code class="highlighter-rouge">last</code> and <code class="highlighter-rouge">rest</code> to
access respectively the first item of the
sequence, the second item, the last item and
the tail of the sequence.  These functions can
be combined to create other functions for
accessing the third, fourth, fifth and other
positional items.  The following functions are
an example of how to construct two such
functions.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">third</span><span class="w">
  </span><span class="p">[</span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">coll</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">third</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 3
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fourth</span><span class="w">
  </span><span class="p">[</span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">coll</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="nf">fourth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 4
</span><span class="w">
</span></code></pre>
</div>
<p>But there is another way.  If, like in this
case, the output of a function can be passed
directly into the input of the next one as a
simple pipeline of functions then you can just
use the <code class="highlighter-rouge">comp</code> function.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (comp f1 f2 f3 ... fn)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="nb">rest</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">fourth</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="nb">rest</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">third</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 3
</span><span class="w">
</span><span class="p">(</span><span class="nf">fourth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 4
</span><span class="w">
</span></code></pre>
</div>
<p>Let’s see another example. Let’s assume
we have to write a function which given
a number it doubles it and subtract 1
from it. So we can use the <code class="highlighter-rouge">multiplier</code>
function we wrote earlier to accomplish
the first part and the Clojure core <code class="highlighter-rouge">dec</code>
to decrement it by one and compose them
together with <code class="highlighter-rouge">comp</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="p">(</span><span class="nf">multiplier</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">almost-twice</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">dec</span><span class="w"> </span><span class="n">doubler</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">almost-twice</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 9
</span><span class="w">
</span><span class="p">(</span><span class="nf">almost-twice</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 17
</span><span class="w">
</span></code></pre>
</div>

<p>Now let’s say we want to create a function
which given a number perform <code class="highlighter-rouge">almost-twice</code> two
times.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">almost-twice-twice</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">almost-twice</span><span class="w"> </span><span class="n">almost-twice</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">almost-twice-twice</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 17
</span><span class="w">
</span><span class="p">(</span><span class="nf">almost-twice-twice</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 37
</span><span class="w">
</span></code></pre>
</div>
<p>Another way we could have written the <code class="highlighter-rouge">doubler</code>
function is by using the partial application of
the function <code class="highlighter-rouge">*</code>. In Clojure this is achieved
via the function <code class="highlighter-rouge">partial</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (partial f arg1 ... argn)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">doubler</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 10
</span><span class="w">
</span></code></pre>
</div>
<p>what happens here is that the <code class="highlighter-rouge">partial</code>
function returns a function which calls <code class="highlighter-rouge">*</code>
with the parameters of the partial and the
parameter of the final call, all in one call.</p>

<p>Another nice example is using the function
<code class="highlighter-rouge">format</code> which takes a format-string and a
bunch of arguments and formats the string
accordingly. This is very similar to the C
<code class="highlighter-rouge">printf</code> function however Clojure uses the Java
<code class="highlighter-rouge">String.format</code> implementation.  So we can use
this to create a function that produces a
string which contains a zero-padded formatted
version of the given number.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">pad0</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="s">"%013d"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">pad0</span><span class="w"> </span><span class="mi">43</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "0000000000043"
</span><span class="w">
</span><span class="p">(</span><span class="nf">pad0</span><span class="w"> </span><span class="mi">2346765847</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "0002346765847"
</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">item-location</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="s">"Section: %d, Row %d, Shelve: %s"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">item-location</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="s">"F"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "Section: 3, Row 12, Shelve: F"
</span><span class="w">

</span></code></pre>
</div>

<h3 id="vars-namespaces-scope-and-local-bindings">Vars, namespaces, scope and local bindings</h3>

<p>When defining a var using <code class="highlighter-rouge">def</code> or <code class="highlighter-rouge">defn</code>
followed by symbol, the symbol is created
in the local namespace.
When starting the REPL in a empty project
the default namespace is called <code class="highlighter-rouge">user</code>
so unless you configure differently
all your vars will be created there.</p>

<p>Namespaces are like containers in which
vars live in, but namespaces,
once defined are <strong>globally accessible</strong>.
As a consequence when you define a var
using <code class="highlighter-rouge">def</code> or <code class="highlighter-rouge">defn</code> these will be accessible
globally.</p>

<p>We will use <code class="highlighter-rouge">ns</code> which create a namespace if
not present and switch to it, and <code class="highlighter-rouge">in-ns</code> just
changes the current namespace.  we will see how
to loads namespaces we need with our processing
with <code class="highlighter-rouge">require</code> and how vars are globally
accessible.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">

</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.one</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="s">"john"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.one/my-name
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "john"
</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.two</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="s">"julie"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.two/my-name
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "julie"
</span><span class="w">
</span><span class="n">user.test.one/my-name</span><span class="w">
</span><span class="c1">;;=&gt; "john"
</span><span class="w">
</span><span class="n">user.test.two/my-name</span><span class="w">
</span><span class="c1">;;=&gt; "julie"
</span><span class="w">
</span><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'user.test.one</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; #namespace[user.test.one]
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "john"
</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.one</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/upper-case</span><span class="w"> </span><span class="s">"john"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.one/my-name
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "JOHN"
</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.one</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">s</span><span class="p">]))</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="p">(</span><span class="nf">s/upper-case</span><span class="w"> </span><span class="s">"john"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.one/my-name
</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.one</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">upper-case</span><span class="p">]]))</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="p">(</span><span class="nf">upper-case</span><span class="w"> </span><span class="s">"john"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.one/my-name
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "JOHN"
</span><span class="w">
</span><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">user.test.one</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">upper-case</span><span class="p">]])</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">user.test.two</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">two</span><span class="p">]))</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-name</span><span class="w"> </span><span class="p">(</span><span class="nf">upper-case</span><span class="w"> </span><span class="n">two/my-name</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; #'user.test.one/my-name
</span><span class="w">
</span><span class="n">my-name</span><span class="w">
</span><span class="c1">;;=&gt; "JULIE"
</span><span class="w">
</span></code></pre>
</div>

<p>The global accessible vars (globals) is one
level of scoping. If you don’t want to have
globally accessible vars then you have to
use local bindings.</p>

<p>We already had a glimpse of these while
defining functions. In fact parameters
are only visible inside the function:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sum</span><span class="w">
  </span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w">

</span></code></pre>
</div>
<p>In this example <code class="highlighter-rouge">v1</code> and <code class="highlighter-rouge">v2</code> are only
accessible inside the function. Outside might
be undefined or have a different value:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="s">"hello"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="s">"world"</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">sum</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 35
</span><span class="w">
</span><span class="n">v1</span><span class="w">
</span><span class="c1">;;=&gt; "hello"
</span><span class="w">
</span><span class="n">v2</span><span class="w">
</span><span class="c1">;;=&gt; "world"
</span><span class="w">
</span></code></pre>
</div>

<p>There is another way to create local binding
which are valid only inside the s-expr block,
using <code class="highlighter-rouge">let</code>.  With the let form you can create
local variable which are visible only inside
the block.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="mi">23</span><span class="w">
      </span><span class="n">v2</span><span class="w"> </span><span class="mi">45</span><span class="p">]</span><span class="w">
  </span><span class="c1">;; inside this block v1 v2 have the values 23 and 45
</span><span class="w">  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; 68
</span><span class="w">
</span></code></pre>
</div>

<p>outside the block v1 and v2 are resolved in the
parent scope which in this case is the
namespace/global You can even nest <code class="highlighter-rouge">let</code>
bindings and use them inside functions.  Here
we use <code class="highlighter-rouge">println</code> to print to the standard
output a message</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="s">"this is a local value"</span><span class="p">]</span><span class="w"> </span><span class="c1">;; outer block
</span><span class="w">  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"outer-v1:"</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">;; inner block
</span><span class="w">    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"inner-v1:"</span><span class="w"> </span><span class="n">v1</span><span class="p">))</span><span class="w">

  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"after-v1:"</span><span class="w"> </span><span class="n">v1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"global-v1:"</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w">  </span><span class="c1">;; global
</span><span class="w">
</span><span class="c1">;;=&gt; outer-v1: this is a local value
;;=&gt; inner-v1: 1
;;=&gt; after-v1: this is a local value
;;=&gt; global-v1: hello
</span><span class="w">

</span></code></pre>
</div>

<h3 id="destructuring">Destructuring</h3>

<p>Destructuring is a simple, yet powerful feature
of Clojure. There are several ways in which you
can leverage destructuring to make your code
cleaner, with less repetitions, and less
bug-prone code.  Destructuring is a way to
unpack a collection into values and bind them
to locals.  It takes a bit of exercise to make
the eye used to read destructuring forms, but
once done, the code appears much cleaner.  I
won’t cover the destructuring here, however I
wrote a detailed post about the topic which you
can find here: <a href="http://blog.brunobonacci.com/2014/11/16/clojure-complete-guide-to-destructuring/">The complete guide to Clojure
destructuring</a></p>

<h3 id="flow-control">Flow control</h3>

<p>We briefly introduced <code class="highlighter-rouge">if</code> for flow control,
which is the basic form on top of which all the
others are based upon.  Moreover there are more
options for flow control in Clojure which we
will see i.e <code class="highlighter-rouge">if</code>,<code class="highlighter-rouge">not</code>, <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code>, <code class="highlighter-rouge">if-not</code>,
<code class="highlighter-rouge">when</code>, <code class="highlighter-rouge">when-not</code>, <code class="highlighter-rouge">cond</code> and <code class="highlighter-rouge">case</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(if condition
    then
    else)
</code></pre>
</div>

<p>the <code class="highlighter-rouge">condition</code> doesn’t have to be a boolean
expression necessarily as, in Clojure, anything
is considered to be <code class="highlighter-rouge">true</code> except <code class="highlighter-rouge">false</code> and
<code class="highlighter-rouge">nil</code> As you would expect if the <code class="highlighter-rouge">condition</code> is
evaluated to be true the <code class="highlighter-rouge">then</code> expression is
evaluated, otherwise the <code class="highlighter-rouge">else</code> expression is
evaluated.  The overall result will be
determined by the result of the expression
which is evaluated.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
  </span><span class="s">"this is true"</span><span class="w">
  </span><span class="s">"this is false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "this is true"
</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
  </span><span class="s">"this is true"</span><span class="w">
  </span><span class="s">"this is false"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "this is false"
</span><span class="w">
</span></code></pre>
</div>

<p>Some times you don’t have <code class="highlighter-rouge">else</code> clause,
so you can omit it.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"that's odd"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; that's odd
;;=&gt; nil
</span><span class="w">
</span></code></pre>
</div>

<p>when you have <code class="highlighter-rouge">if</code> and <code class="highlighter-rouge">not</code> together you can
combine them in <code class="highlighter-rouge">if-not</code></p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">if-not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"that's odd"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; that's odd
;;=&gt; nil
</span><span class="w">
</span></code></pre>
</div>
<p>But when there is no else expression
a more idiomatic way to write it in Clojure
would be to use the form <code class="highlighter-rouge">when</code>, and similarly
when you have a negation in your condition
you can use <code class="highlighter-rouge">when-not</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">not=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"that's odd"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; that's odd
;;=&gt; nil
</span><span class="w">
</span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"that's odd"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; that's odd
;;=&gt; nil
</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">when</code> accepts more than one expression and the
result of the overall expression is the result
of last form, or <code class="highlighter-rouge">nil</code> if the condition is
false.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="mi">1</span><span class="w">
  </span><span class="mi">2</span><span class="w">
  </span><span class="mi">3</span><span class="w">
  </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 4
</span><span class="w">
</span></code></pre>
</div>

<p>However <code class="highlighter-rouge">if</code> accepts one form for the then, and
another form for the <code class="highlighter-rouge">else</code> when given. If you
have to invoke several functions perhaps with
side-effect, then you have to use the <code class="highlighter-rouge">do</code>
form.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">do</span><span class="w">
  </span><span class="mi">1</span><span class="w">
  </span><span class="mi">2</span><span class="w">
  </span><span class="mi">3</span><span class="w">
  </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 4
</span><span class="w">

</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="p">(</span><span class="nf">do</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"this is executed when true"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"this one too."</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"the next line is the value returned"</span><span class="p">)</span><span class="w">
    </span><span class="no">:ok</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">do</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"this is executed in the else"</span><span class="p">)</span><span class="w">
    </span><span class="no">:this-is-else</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; this is executed when true
;;=&gt; this one too.
;;=&gt; the next line is the value returned
;;=&gt; :ok
</span><span class="w">

</span></code></pre>
</div>

<p>If you have to check the equality to many
different values you can use the <code class="highlighter-rouge">case</code>
which is similar to <code class="highlighter-rouge">switch/case</code> of many
languages. In Clojure it looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(case value
   val1  expr1
   val2  expr2
   val3  expr3
   default-exp)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">order-status</span><span class="w"> </span><span class="no">:completed</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">order-status</span><span class="w">
    </span><span class="no">:new</span><span class="w">         </span><span class="s">"We have received your order, thanks."</span><span class="w">
    </span><span class="no">:processing</span><span class="w">  </span><span class="s">"We are processing your order"</span><span class="w">
    </span><span class="no">:ready</span><span class="w">       </span><span class="s">"We are processing your order"</span><span class="w">
    </span><span class="no">:shipped</span><span class="w">     </span><span class="s">"Your order is on it's way"</span><span class="w">
    </span><span class="no">:completed</span><span class="w">   </span><span class="s">"This order has been already delivered"</span><span class="w">
    </span><span class="s">"This order is not found"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "This order has been already delivered"
</span><span class="w">
</span></code></pre>
</div>

<p>If you have multiple value with the same
expression you can group them in a list.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">order-status</span><span class="w"> </span><span class="no">:ready</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">order-status</span><span class="w">
    </span><span class="no">:new</span><span class="w">         </span><span class="s">"We have received your order, thanks."</span><span class="w">
    </span><span class="p">(</span><span class="no">:processing</span><span class="w"> </span><span class="no">:ready</span><span class="p">)</span><span class="w">   </span><span class="s">"We are processing your order"</span><span class="w">
    </span><span class="no">:shipped</span><span class="w">     </span><span class="s">"Your order is on it's way"</span><span class="w">
    </span><span class="no">:completed</span><span class="w">   </span><span class="s">"This order has been already delivered"</span><span class="w">
    </span><span class="s">"This order is not found"</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "We are processing your order"
</span><span class="w">

</span></code></pre>
</div>

<p>Another very popular conditional form is
<code class="highlighter-rouge">cond</code>, this is used in place of their
<code class="highlighter-rouge">if/else-if/else-if/else</code> of other languages.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(cond
   condition1 expr1
   condition2 expr2
   condition3 expr3
   :else default-expr)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">age</span><span class="w"> </span><span class="mi">21</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="s">"You are too young to drive"</span><span class="w">
    </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="s">"You can start your driving lessons"</span><span class="w">
    </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="s">"You can drive only if you have got a license"</span><span class="w">
    </span><span class="no">:else</span><span class="w"> </span><span class="s">"Maybe you should let someone else driving."</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; "You can drive only if you have got a license"
</span><span class="w">

</span></code></pre>
</div>

<p>If you have complicated conditions you might
have to combine the conditions logically with <code class="highlighter-rouge">and</code>,
<code class="highlighter-rouge">or</code> and <code class="highlighter-rouge">not</code>. We’ve already seen <code class="highlighter-rouge">not</code> which
negates the given condition, while <code class="highlighter-rouge">and</code> and
<code class="highlighter-rouge">or</code> work as you would expect.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(and
  condition1
  condition2
  condition3)
</code></pre>
</div>

<p>the value of the entire expression is the value
of the last condition. If a condition is found
to be falsey (<code class="highlighter-rouge">false</code> or <code class="highlighter-rouge">nil</code>) the
evaluation is interrupted and the whole expression
will have the value of last evaluated expression.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 4
</span><span class="w">
</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">
</span></code></pre>
</div>

<p>Similarly <code class="highlighter-rouge">or</code> accepts multiple conditions,
and they are evaluated in the given order,
and the first condition which is found to
be true will stop the evaluation
and return its value as the value of the
the whole expression.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; 1
</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">or</code> is often used to provide default
values to parameters function via destructuring
however it can be used in normal code as well.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">connection-url</span><span class="w"> </span><span class="p">[</span><span class="n">config-map</span><span class="w"> </span><span class="n">resource</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">protocol</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:protocol</span><span class="w"> </span><span class="n">config-map</span><span class="p">)</span><span class="w"> </span><span class="s">"http"</span><span class="p">)</span><span class="w">
        </span><span class="n">hostname</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:hostname</span><span class="w"> </span><span class="n">config-map</span><span class="p">)</span><span class="w"> </span><span class="s">"localhost"</span><span class="p">)</span><span class="w">
        </span><span class="n">port</span><span class="w">     </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:port</span><span class="w">     </span><span class="n">config-map</span><span class="p">)</span><span class="w"> </span><span class="mi">8080</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">protocol</span><span class="w"> </span><span class="s">"://"</span><span class="w"> </span><span class="n">hostname</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nf">connection-url</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="s">"/users"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "http://localhost:8080/users"
</span><span class="w">
</span></code></pre>
</div>

<p>Obviously you can combine <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code> and <code class="highlighter-rouge">not</code>
to create arbitrary complex conditions.</p>

<h3 id="core-functions">Core functions</h3>

<p>The core has hundreds of functions defined,
which all work on the basic data structures
that we’ve seen so far. You can find the full list
in the <a href="http://clojure.org/api/cheatsheet">Clojure cheatsheet</a></p>

<h4 id="the-function-apply">The function: <code class="highlighter-rouge">apply</code></h4>

<p>For the purpose of this course we will
only see a few examples starting with <code class="highlighter-rouge">apply</code>.
As the same suggests, it “applies” a function
to a given list of arguments.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (apply f args)
 (apply f x args)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">words</span><span class="w"> </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; "[\"Hello\" \" \" \"world!\"]"
</span><span class="w">
</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; "Hello world!"
</span><span class="w">
</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="s">"first-argument: "</span><span class="w"> </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; "first-argument: Hello world!"
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-map">The function: <code class="highlighter-rouge">map</code></h4>

<p>Next we will see one of the most used functions
in the core <code class="highlighter-rouge">map</code> which has nothing to do with
the associative maps (data structures) we seen
before.  <code class="highlighter-rouge">map</code> comes from the set theory and is
a function which takes a function and a
sequence of values and applies the function to
all values in the sequence. It returns a
lazy-sequence which means that the function
application is not performed when calling <code class="highlighter-rouge">map</code>,
but it will be performed when the result will
be consumed.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (map f coll)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">clojure.string/upper-case</span><span class="w">
     </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("HELLO" "WORLD!")
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-mapcat">The function: <code class="highlighter-rouge">mapcat</code></h4>

<p>Sometimes the application of the function <code class="highlighter-rouge">f</code>
returns a list of things. In the following
example, applying the split function to each sentence
spilts each sentence and returns a list of words.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"\W+"</span><span class="p">)</span><span class="w">
     </span><span class="p">[</span><span class="s">"Lorem ipsum dolor sit amet, consectetur adipiscing elit."</span><span class="w">
      </span><span class="s">"Duis vel ante est."</span><span class="w">
      </span><span class="s">"Pellentesque habitant morbi tristique"</span><span class="w">
      </span><span class="s">"senectus et netus et malesuada fames ac turpis egestas."</span><span class="p">])</span><span class="w">

</span><span class="c1">;;=&gt; (["Lorem" "ipsum" "dolor" "sit" "amet" "consectetur" "adipiscing" "elit"] ["Duis" "vel" "ante" "est"] ["Pellentesque" "habitant" "morbi" "tristique"] ["senectus" "et" "netus" "et" "malesuada" "fames" "ac" "turpis" "egestas"])
</span><span class="w">
</span></code></pre>
</div>
<p>application of the split function to a single
sentence produces a list of words. Consequently
the application of the function to all
sentences produces a list of lists.  If we
rather have a single list with all the words we
then need to concatenate all the sub-lists into
one.  To do so Clojure core has the <code class="highlighter-rouge">concat</code>
function which just concatenates multiple lists
into one.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">]</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (0 1 2 3 :a :b :c d e f)
</span><span class="w">
</span></code></pre>
</div>
<p>To obtain a single list of all words we just need
to apply the <code class="highlighter-rouge">concat</code> function to the <code class="highlighter-rouge">map</code> result.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">concat</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"\W+"</span><span class="p">)</span><span class="w">
            </span><span class="p">[</span><span class="s">"Lorem ipsum dolor sit amet, consectetur adipiscing elit."</span><span class="w">
             </span><span class="s">"Duis vel ante est."</span><span class="w">
             </span><span class="s">"Pellentesque habitant morbi tristique"</span><span class="w">
             </span><span class="s">"senectus et netus et malesuada fames ac turpis egestas."</span><span class="p">]))</span><span class="w">
</span><span class="c1">;;=&gt; ("Lorem" "ipsum" "dolor" "sit" "amet" "consectetur" "adipiscing" "elit" "Duis" "vel" "ante" "est" "Pellentesque" "habitant" "morbi" "tristique" "senectus" "et" "netus" "et" "malesuada" "fames" "ac" "turpis" "egestas")
</span><span class="w">
</span></code></pre>
</div>

<p>This construct is common enough that Clojure has
a core function that does just this called <code class="highlighter-rouge">mapcat</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"\W+"</span><span class="p">)</span><span class="w">
        </span><span class="p">[</span><span class="s">"Lorem ipsum dolor sit amet, consectetur adipiscing elit."</span><span class="w">
         </span><span class="s">"Duis vel ante est."</span><span class="w">
         </span><span class="s">"Pellentesque habitant morbi tristique"</span><span class="w">
         </span><span class="s">"senectus et netus et malesuada fames ac turpis egestas."</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("Lorem" "ipsum" "dolor" "sit" "amet" "consectetur" "adipiscing" "elit" "Duis" "vel" "ante" "est" "Pellentesque" "habitant" "morbi" "tristique" "senectus" "et" "netus" "et" "malesuada" "fames" "ac" "turpis" "egestas")
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-reduce">The function: <code class="highlighter-rouge">reduce</code></h4>

<p>Hadoop uses the two concept of <code class="highlighter-rouge">map</code> and
<code class="highlighter-rouge">reduce</code> to perform arbitrary computation on
large data.  Clojure has <code class="highlighter-rouge">reduce</code> as core
function as well.  While <code class="highlighter-rouge">map</code> is applied
one-by-one to all arguments with the objective
of performing a transformation <code class="highlighter-rouge">reduce</code> seeks
to summarize many values into one.  For example
if you want to find the total sum of a list of
values you can use reduce in the following way.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (reduce f coll)
</code></pre>
</div>

<p>It can be used with many core functions
like the arithmetic functions <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code>
but also with functions like <code class="highlighter-rouge">max</code> and <code class="highlighter-rouge">min</code>
which respectively return the highest and
the lowest value passed. But they
can be used with your own functions too.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="mi">54</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">11</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; 200
</span><span class="w">
</span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="mi">54</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">11</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; 33838041600
</span><span class="w">
</span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="mi">54</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">11</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; 54
</span><span class="w">
</span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="s">"Hello"</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">"world!"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; "Hello world!"
</span><span class="w">

</span></code></pre>
</div>

<h4 id="the-function-filter">The function: <code class="highlighter-rouge">filter</code></h4>

<p>The next function in the core is <code class="highlighter-rouge">filter</code> which
takes a <em>predicate function</em> and a collection
and returns a lazy-sequence of the items in the
collection for which the application of the
function returns a “truthy” value.  Predicate
functions are functions which takes one
parameter and return a logical true or false.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (filter pred? coll)
</code></pre>
</div>

<p>For example:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">odd?</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (1 3 5 7)
</span><span class="w">
</span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
        </span><span class="p">[</span><span class="s">"Lorem"</span><span class="w"> </span><span class="s">"ipsum"</span><span class="w"> </span><span class="s">"dolor"</span><span class="w"> </span><span class="s">"sit"</span><span class="w"> </span><span class="s">"amet"</span><span class="w"> </span><span class="s">"consectetur"</span><span class="w"> </span><span class="s">"adipiscing"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("consectetur" "adipiscing")
</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">identity</code> is a function which given a value
will just return the value.
This is often used when a function transformation
is required as parameter, but no transformation is wanted.
another idiomatic use of it is to remove nil and false
from a collection.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">identity</span><span class="w">
        </span><span class="p">[</span><span class="s">"Lorem"</span><span class="w"> </span><span class="s">"ipsum"</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="s">"sit"</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="s">"consectetur"</span><span class="w"> </span><span class="n">nil</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("Lorem" "ipsum" "sit" "consectetur")
</span><span class="w">
</span></code></pre>
</div>

<p>The function <code class="highlighter-rouge">remove</code> is the dual of <code class="highlighter-rouge">filter</code>
in the sense that is will remove the items
for which the predicate function returns true.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">odd?</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (1 3 5 7)
</span><span class="w">
</span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="n">odd?</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (0 2 4 6)
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-sort">The function: <code class="highlighter-rouge">sort</code></h4>

<p><code class="highlighter-rouge">sort</code> as you would expect returns a sorted
sequence of the elements in the given collection.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (sort coll)
 (sort comp coll)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">sort</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (0 1 2 3 3 4 5 5 7 8 9)
</span><span class="w">
</span><span class="p">(</span><span class="nb">sort</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; (9 8 7 5 5 4 3 3 2 1 0)
</span><span class="w">
</span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="nb">count</span><span class="w">
         </span><span class="p">[</span><span class="s">"Lorem"</span><span class="w"> </span><span class="s">"ipsum"</span><span class="w"> </span><span class="s">"dolor"</span><span class="w"> </span><span class="s">"sit"</span><span class="w"> </span><span class="s">"amet"</span><span class="w"> </span><span class="s">"consectetur"</span><span class="w"> </span><span class="s">"adipiscing"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("sit" "amet" "Lorem" "ipsum" "dolor" "adipiscing" "consectetur")
</span><span class="w">
</span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="nb">&gt;</span><span class="w">
         </span><span class="p">[</span><span class="s">"Lorem"</span><span class="w"> </span><span class="s">"ipsum"</span><span class="w"> </span><span class="s">"dolor"</span><span class="w"> </span><span class="s">"sit"</span><span class="w"> </span><span class="s">"amet"</span><span class="w"> </span><span class="s">"consectetur"</span><span class="w"> </span><span class="s">"adipiscing"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; ("consectetur" "adipiscing" "Lorem" "ipsum" "dolor" "amet" "sit")
</span><span class="w">
</span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="no">:score</span><span class="w"> </span><span class="nb">&gt;</span><span class="w">
         </span><span class="p">[{</span><span class="no">:user</span><span class="w"> </span><span class="s">"john1"</span><span class="w"> </span><span class="no">:score</span><span class="w"> </span><span class="mi">345</span><span class="p">}</span><span class="w">
          </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"fred3"</span><span class="w"> </span><span class="no">:score</span><span class="w"> </span><span class="mi">75</span><span class="p">}</span><span class="w">
          </span><span class="p">{</span><span class="no">:user</span><span class="w"> </span><span class="s">"sam2"</span><span class="w">  </span><span class="no">:score</span><span class="w"> </span><span class="mi">291</span><span class="p">}])</span><span class="w">
</span><span class="c1">;;=&gt; ({:user "john1", :score 345} {:user "sam2", :score 291} {:user "fred3", :score 75})
</span><span class="w">
</span></code></pre>
</div>

<p>A similar function is <code class="highlighter-rouge">sort-by</code> which accepts a
function which is applied to the item before the
comparison.</p>

<h4 id="the-function-group-by">The function: <code class="highlighter-rouge">group-by</code></h4>

<p>Out of the box in Clojure you have a function
to perform grouping on your data.  <code class="highlighter-rouge">group-by</code>
accepts a function and a collection and it will
apply the given function to all items in the
collection and then group the items using the
result of the function, i.e items that give the
same result when the function is applied end up
in the same group.  Each group will be
associated with it’s common function result.
It returns a map where the key is the group
common function result, and the value of the
map is a list of items which belong to that
group.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="n">odd?</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; {false [0 2 4 6 8], true [1 3 5 7 9]}
</span><span class="w">

</span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="p">[</span><span class="s">"Lorem"</span><span class="w"> </span><span class="s">"ipsum"</span><span class="w"> </span><span class="s">"dolor"</span><span class="w"> </span><span class="s">"sit"</span><span class="w"> </span><span class="s">"amet"</span><span class="w"> </span><span class="s">"consectetur"</span><span class="w"> </span><span class="s">"adipiscing"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; {5 ["Lorem" "ipsum" "dolor"], 3 ["sit"], 4 ["amet"], 11 ["consectetur"], 10 ["adipiscing"]}
</span><span class="w">
</span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="no">:user-id</span><span class="w"> </span><span class="p">[{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/"</span><span class="p">}</span><span class="w">
                    </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/foo"</span><span class="p">}</span><span class="w">
                    </span><span class="p">{</span><span class="no">:user-id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:uri</span><span class="w"> </span><span class="s">"/account"</span><span class="p">}])</span><span class="w">
</span><span class="c1">;;=&gt; {1 [{:user-id 1, :uri "/"} {:user-id 1, :uri "/account"}], 2 [{:user-id 2, :uri "/foo"}]}
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-frequencies">The function: <code class="highlighter-rouge">frequencies</code></h4>

<p>When looking to count how frequent an item appears
in a collection for example to compute histograms
you can use the function called <code class="highlighter-rouge">frequencies</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">frequencies</span><span class="w"> </span><span class="p">[</span><span class="s">"john"</span><span class="w"> </span><span class="s">"fred"</span><span class="w"> </span><span class="s">"alice"</span><span class="w"> </span><span class="s">"fred"</span><span class="w"> </span><span class="s">"jason"</span><span class="w"> </span><span class="s">"john"</span><span class="w"> </span><span class="s">"alice"</span><span class="w"> </span><span class="s">"john"</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; {"john" 3, "fred" 2, "alice" 2, "jason" 1}
</span><span class="w">

</span><span class="p">(</span><span class="nf">frequencies</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="c1">;;=&gt; {1 3, 2 6, 3 7, 4 2}
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-partition">The function: <code class="highlighter-rouge">partition</code></h4>

<p>Another interesting group of functions in the Clojure
core are <code class="highlighter-rouge">partition</code>, <code class="highlighter-rouge">partition-all</code>, <code class="highlighter-rouge">partition-by</code>.
Here we will see only the first two.
<code class="highlighter-rouge">partition</code> chunks the given sequence into
sub-sequences (lazy) of <code class="highlighter-rouge">n</code> items each.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (partition n coll)
 (partition n step coll)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">11</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; ((0 1 2) (3 4 5) (6 7 8))
</span><span class="w">
</span></code></pre>
</div>
<p><code class="highlighter-rouge">partition-all</code> does the same, but it returns
also chunks of which are incomplete.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">partition-all</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">11</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; ((0 1 2) (3 4 5) (6 7 8) (9 10))
</span><span class="w">
</span></code></pre>
</div>

<p>The <code class="highlighter-rouge">step</code> parameters tells the function how
many item has to move forward after every
chunk.  if not given <code class="highlighter-rouge">step</code> is equal to <code class="highlighter-rouge">n</code></p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">11</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; ((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9) (8 9 10))
</span><span class="w">
</span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">11</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; ((0 1 2) (5 6 7))
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-into">The function: <code class="highlighter-rouge">into</code></h4>

<p><code class="highlighter-rouge">into</code> is used to create a new collection of a
given type with all items from another
collection “into” it.  Items are conjoined
using <code class="highlighter-rouge">conj</code>. It is often used to change the
type of a collection, or to build a map out of
key/value pairs.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (into dest source)
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; [0 1 2 3 4 5 6 7 8 9]
</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="o">'</span><span class="p">()</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; (9 8 7 6 5 4 3 2 1 0)
</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">(</span><span class="nb">sorted-map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="n">,</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 2, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">[[</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">]])</span><span class="w">
</span><span class="c1">;;=&gt; {:a 1, :b 2, :c 3}
</span><span class="w">
</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">first</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">e</span><span class="p">))])</span><span class="w">
     </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="c1">;;=&gt; ([:a 2] [:b 3] [:c 4])
</span><span class="w">
</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w">
      </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">first</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">e</span><span class="p">))])</span><span class="w">
           </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w">
</span><span class="c1">;;=&gt; {:a 2, :b 3, :c 4}
</span><span class="w">
</span></code></pre>
</div>

<h4 id="the-function-juxt">The function: <code class="highlighter-rouge">juxt</code></h4>

<p>This function takes a set of functions,
and returns a function which when
called with a argument returns a vector
with all the functions applied to the
argument in the given order.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (juxt f1 f2 f3 ... fn)
</code></pre>
</div>

<p>it returns a function which is equivalent to:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> (fn [x] (vector (f1 x) (f2 x) (f3 x) ...))
</code></pre>
</div>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">string-info</span><span class="w">
  </span><span class="p">(</span><span class="nf">juxt</span><span class="w"> </span><span class="nb">identity</span><span class="w"> </span><span class="n">clojure.string/upper-case</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="n">frequencies</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">string-info</span><span class="w"> </span><span class="s">"Hello World"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; ["Hello World" "HELLO WORLD" 11 {\H 1, \e 1, \l 3, \o 2, \space 1, \W 1, \r 1, \d 1}]
</span><span class="w">

</span></code></pre>
</div>

<h3 id="operation-with-files">Operation with files</h3>

<p>To open, read, write files there are wrappers
from the java machinery for files. However here
we will only see how to read and write text
files which are small enough to fit in memory.</p>

<p>To write some text in a file you can use the
function <code class="highlighter-rouge">spit</code>, while to read the content of a
file as a string you can use <code class="highlighter-rouge">slurp</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="s">"/tmp/my-file.txt"</span><span class="w">
      </span><span class="s">"This is the content"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; nil
</span><span class="w">

</span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"/tmp/my-file.txt"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; "This is the content."
</span><span class="w">
</span></code></pre>
</div>

<h3 id="error-handling">Error handling</h3>

<p>What happens if the file you trying to read
doesn’t exists? or the device you trying to
write to is full? The underlying Java APIs will
throw an exception.  Clojure provides access to
the java machinery for error handling and you
can use <code class="highlighter-rouge">try</code>, <code class="highlighter-rouge">catch</code>, <code class="highlighter-rouge">finally</code> and <code class="highlighter-rouge">throw</code>
with the same semantic as the Java’s ones.</p>

<p>You have to surround the code which might throw
an exception using a <code class="highlighter-rouge">try</code> form, then you can
handle the errors by their native type with a
<code class="highlighter-rouge">catch</code> block.  Finally is a block that gets
executed no matter what happen in the try block and
whether or not an exception is raised.  <code class="highlighter-rouge">throw</code>
is used to throw an exception from your own code.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="w">
</span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"/this_doesnt_exists.txt"</span><span class="p">)</span><span class="w">
</span><span class="c1">;;=&gt; FileNotFoundException /this_doesnt_exists.txt (No such file or directory)
</span><span class="w">

</span><span class="p">(</span><span class="nf">try</span><span class="w">
  </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="s">"/this_doesnt_exists.txt"</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">x</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"unable to read file."</span><span class="p">)</span><span class="w">
    </span><span class="s">""</span><span class="p">))</span><span class="w">
</span><span class="c1">;;=&gt; unable to read file
;;=&gt; ""
</span><span class="w">
</span></code></pre>
</div>

<p><em>Oftentimes while working with network
requests, you might want to retry a given
request a number of times before giving up. In
such cases there is a library called
<a href="https://github.com/BrunoBonacci/safely">safely</a>
which might be handy.</em></p>

<h3 id="macros">Macros</h3>

<p>The macros are function which are executed at
compile time by the compiler. The take code as
input, and the output is still code. The code
is expressed in the same stuff you have seen so
far: lists, symbols, keywords, vectors, maps
strings etc and from a user point of view they
look just like normal Clojure functions
(almost).  It is a great way to extends the
language to meet your domain needs. However I
think this is a topic for a more advanced
course. If you want to learn the basics of the
macro you can read the following blog post:</p>

<p><a href="http://blog.brunobonacci.com/2015/04/19/dead-simple-introduction-to-clojure-macros/">A “dead simple” introduction to Clojure macros.</a></p>


  </section>
  
</article>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2013-2016 Bruno Bonacci. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51571233-1', 'auto');
  ga('send', 'pageview');
</script>


    </div>
  </body>
</html>
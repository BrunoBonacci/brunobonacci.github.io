<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Lazy, Chunked, and Buffered: Understanding Clojure's Lazy Sequences</title>
  <meta name="description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, Software Architecture, and Distributed Systems">
  <meta name="author" content="Bruno Bonacci">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bits and pieces">
  <meta name="twitter:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, Software Architecture, and Distributed Systems">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Bits and pieces">
  <meta property="og:description" content="Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, Software Architecture, and Distributed Systems">

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.brunobonacci.com//2023/09/08/buffered-sequences/">
  <link rel="alternate" type="application/rss+xml" title="Bits and pieces" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Bits and pieces">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Bits and pieces</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Between bits and bytes and all other pieces.<br/>A tech blog about Clojure, Software Architecture, and Distributed Systems</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/projects" title="link to Bits and pieces Projects" class="blog-button">Projects</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="link to Bits and pieces blog" class="blog-button">Blog</a></li>
              </ul>
          </nav>

          <!--
          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/tags" title="link to Bits and pieces tags" class="blog-button">Tags</a></li>
              </ul>
          </nav>

          <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/categories" title="link to Bits and pieces categories" class="blog-button">Categories</a></li>
              </ul>
          </nav>
          -->

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/BrunoBonacci" title="@BrunoBonacci on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/brunobonacci" title="brunobonacci on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/BrunoBonacci" title="BrunoBonacci on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="8 Sep 2023" class="post-meta__date date">8 Sep 2023</time> &#8226; <span class="post-meta__tags">on <a href="/tags/#Clojure">Clojure</a> </span>
    </div>
    <h1 class="post-title">Lazy, Chunked, and Buffered: Understanding Clojure's Lazy Sequences</h1>
  </header>

  <section class="post">
    <p><em>Originally posted at: <a href="https://redefine.io/blog/buffered-sequences/">https://redefine.io/blog/buffered-sequences/</a></em></p>

<p>The Clojure core namespace boasts an impressive array of functions, numbering
over 600 by my estimation. Even with many years of Clojure development under my
belt, I still stumble upon hidden treasures. In this post, I’ll delve into how
the consumption of various lazy sequences influences computation. Lazy sequences
have been a staple in Clojure since version 1.0, so they’re hardly a
novelty. There are distinct types of lazy sequences in Clojure: the “truly” lazy
ones, chunked sequences, and “buffered” sequences. I believe most Clojure
developers will be familiar with at least the first two types. This article
primarily shines a spotlight on the “buffered” sequences (or queued sequences)
and their unique behaviors. Through a series of examples, we’ll navigate the
nuances of these sequences and observe their behaviors upon consumption.</p>

<h2 id="lazy-sequences">Lazy sequences</h2>

<p>In its simplest form, a lazy sequence in Clojure can be constructed using
<a href="https://clojuredocs.org/clojure.core/lazy-seq"><code class="highlighter-rouge">lazy-seq</code></a>. <code class="highlighter-rouge">lazy-seq</code> takes a
body of expressions and it delays the evaluation until it is requested,
similarly to an <code class="highlighter-rouge">iterator</code> that executes the body only when the <code class="highlighter-rouge">.next()</code> method
is invoked.  For instance, to create a lazy sequence of all integer numbers we
can write:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-lazy-seq</span><span class="w">
  </span><span class="p">([]</span><span class="w">
   </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="w">
   </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w">
     </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">n</span><span class="w">
       </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>There are many other functions in the Clojure core which
return lazy sequences as well.  For example we could rewrite the previous
function using <a href="https://clojuredocs.org/clojure.core/iterate"><code class="highlighter-rouge">iterate</code></a>:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-lazy-seq</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>The two functions are equivalent. To illustrate the different behaviours let’s
introduce two functions: <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">process</code>. For the sake of the example let’s
assume that <code class="highlighter-rouge">my-lazy-seq</code> returns the path of files to be processed, or the ids
of some database records to be processed, the function <code class="highlighter-rouge">load</code> will simulate the
retrieval from the db, and the function <code class="highlighter-rouge">process</code> represents a function
performing computations on the retrieved data.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">load</span><span class="w">
  </span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">"Loading: %d \n"</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w">
  </span><span class="n">v</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process</span><span class="w">
  </span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">"Processing: %d \n"</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">600</span><span class="p">)</span><span class="w">
  </span><span class="n">v</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>To process the first 10 items of <code class="highlighter-rouge">my-lazy-seq</code> we could write:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>There are a few things to point out from the above lines:</p>
<ol>
  <li>evaluating this expression won’t cause the execution of neither <code class="highlighter-rouge">load</code> nor
the <code class="highlighter-rouge">precess</code> function.</li>
  <li><code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">take</code> both return lazy sequences, therefore evaluating the
expression will only create a chain of lazy sequences which upon
consumption will cause a chain reaction of <code class="highlighter-rouge">load</code>/<code class="highlighter-rouge">process</code> calls.</li>
  <li>evaluating the code in a REPL or an IDE will certainly trigger the
execution of the <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">process</code> functions because the REPL will
attempt to print the result. The default behaviour of the REPL is to print
the content of a sequence up to the
<a href="https://clojuredocs.org/clojure.core/*print-length*"><code class="highlighter-rouge">*print-length*</code></a>. It
is good practice to set a limit into to your REPL configuration. For example:
<code class="highlighter-rouge">(set! *print-length* 100)</code> will tell the REPL to only consume and print
the first 100 items of a sequence. The default value is <code class="highlighter-rouge">nil</code> which tells
the REPL to consume it all. Evaluating lazy infinite sequences like <code class="highlighter-rouge">my-lazy-seq</code>
on the REPL without <code class="highlighter-rouge">*print-length*</code> will cause the REPL to hang.</li>
  <li>For completeness I will add a <code class="highlighter-rouge">doall</code> at the end of each evaluation to
force the lazy sequence to be realized regardless of a specific <code class="highlighter-rouge">*print-length*</code>
configuration.</li>
</ol>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Loading: 0
;; Processing: 0
;; Loading: 1
;; Processing: 1
;; Loading: 2
;; Processing: 2
;; Loading: 3
;; Processing: 3
;; Loading: 4
;; Processing: 4
;; Loading: 5
;; Processing: 5
;; Loading: 6
;; Processing: 6
;; Loading: 7
;; Processing: 7
;; Loading: 8
;; Processing: 8
;; Loading: 9
;; Processing: 9
;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>That’s pretty much what we expected. Every item of the lazy sequence is loaded
first and then processed in a strict succession.</p>

<p>To better visualize what is happening I’ve instrumented the <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">process</code>
functions with <a href="https://github.com/BrunoBonacci/mulog#%CE%BCtrace"><code class="highlighter-rouge">μ/trace</code></a>
and published the traces into <a href="https://www.jaegertracing.io/">Jaeger</a>.</p>

<p>Looking the above execution this is what I get:</p>

<p><img src="/images/seque/lazy.jpg" alt="lazy evaluation" /></p>

<p><code class="highlighter-rouge">μ/trace</code> makes it incredibly easy to visualize the sequence of operations. I
use it all the time to reinforce my mental model of how some operations are
executed in larger applications.</p>

<h2 id="chunked-sequences">Chunked sequences</h2>

<p>Chunked sequences are an optimisation to reduce the allocation.
A chunked sequence instead of realizing one element at the time,
it will realize a chunk of them (usually 32). From a consumer
point of view, it is almost totally transparent. The prime
example of chunked sequences is the
<a href="https://clojuredocs.org/clojure.core/range"><code class="highlighter-rouge">range</code></a> function.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span><span class="w">
</span><span class="p">(</span><span class="nf">chunked-seq?</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nf">chunked-seq?</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; false
</span></code></pre>
</div>

<p>The chunking effect can be seen when applying a transformation like in our
previous example. If we replace <code class="highlighter-rouge">my-lazy-seq</code> with <code class="highlighter-rouge">range</code>, we see something
interesting.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; clean
</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Loading: 0
;; Loading: 1
;; Loading: 2
;; Loading: 3
;; Loading: 4
;; Loading: 5
;; Loading: 6
;; Loading: 7
;; Loading: 8
;; Loading: 9
;; Loading: 10
;; Loading: 11
;; Loading: 12
;; Loading: 13
;; Loading: 14
;; Loading: 15
;; Loading: 16
;; Loading: 17
;; Loading: 18
;; Loading: 19
;; Loading: 20
;; Loading: 21
;; Loading: 22
;; Loading: 23
;; Loading: 24
;; Loading: 25
;; Loading: 26
;; Loading: 27
;; Loading: 28
;; Loading: 29
;; Loading: 30
;; Loading: 31
;; Processing: 0
;; Processing: 1
;; Processing: 2
;; Processing: 3
;; Processing: 4
;; Processing: 5
;; Processing: 6
;; Processing: 7
;; Processing: 8
;; Processing: 9
;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>Notice that despite the fact we only consumed 10 items from the result, 32 items
were realized from the first sequence and loaded, then <code class="highlighter-rouge">(map load)</code> returns a
true lazy sequence so only 10 items were <code class="highlighter-rouge">processed</code>.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">chunked-seq?</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; true
</span><span class="w">
</span><span class="p">(</span><span class="nf">chunked-seq?</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">100</span><span class="p">)))</span><span class="w">
</span><span class="c1">;; =&gt; false
</span></code></pre>
</div>
<p>If we look at the execution trace of our previous example we can see that nicely:</p>

<p><img src="/images/seque/chunked.jpg" alt="chunked" /></p>

<p>As you attempt to realize the first item, the initial chunk of 32 items is
realized. All these items remain in memory until the chunk is entirely
consumed. Once the consumer requests the 33rd item, a new chunk of 32 items is
realized.</p>

<p>Chunked sequences are beneficial when the cost of realizing each item is
minimal, offering an optimization in terms of allocations.</p>

<p>To create a chunked sequence the Clojure core provides a set of functions:
<a href="https://clojuredocs.org/clojure.core/chunk-buffer"><code class="highlighter-rouge">chunk-buffer</code></a>,
<a href="https://clojuredocs.org/clojure.core/chunk"><code class="highlighter-rouge">chunk</code></a>,
<a href="https://clojuredocs.org/clojure.core/chunk-append"><code class="highlighter-rouge">chunk-append</code></a>,
<a href="https://clojuredocs.org/clojure.core/chunk-cons"><code class="highlighter-rouge">chunk-cons</code></a>,
<a href="https://clojuredocs.org/clojure.core/chunk-rest"><code class="highlighter-rouge">chunk-rest</code></a> and
<a href="https://clojuredocs.org/clojure.core/chunked-seq_q"><code class="highlighter-rouge">chunked-seq?</code></a> which we
have already seen.</p>

<h2 id="buffered-sequences">Buffered sequences</h2>

<p>Buffered sequences share some similarities with chunked sequences, but they
exhibit a slightly different behavior. Their main goal is to minimize the wait
time for consumers by storing a set number of realized items in a buffer (or
queue). Buffered sequences maintain a fixed-length buffer. A Clojure agent works
diligently to ensure the buffer is consistently populated with realized
items. Consequently, when the consumer requires a new item for processing,
multiple items are readily available.</p>

<p><img src="/images/seque/buffer.png" alt="buffer" /></p>

<p>On the right, there’s an unrealized lazy sequence. A Clojure agent will try to
fill the buffer as swiftly as possible. The items in the buffer are always in a
realized state. The consumer then retrieves items from the buffer in the same
sequence order (FIFO) for further processing.</p>

<p>The Clojure core to build such sequences is <a href="https://clojuredocs.org/clojure.core/seque"><code class="highlighter-rouge">seque</code></a>.</p>

<p>Let’s examine how buffered sequences impact computation, using our previous example.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">seque</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">    </span><span class="c1">;; buffer of 5
</span><span class="w">  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Loading: 0
;; Loading: 1
;; Loading: 2
;; Processing: 0
;; Loading: 3
;; Loading: 4
;; Processing: 1
;; Loading: 5
;; Loading: 6
;; Loading: 7
;; Processing: 2
;; Loading: 8
;; Loading: 9
;; Processing: 3
;; Loading: 10
;; Processing: 4
;; Loading: 11
;; Processing: 5
;; Loading: 12
;; Processing: 6
;; Loading: 13
;; Loading: 14
;; Processing: 7
;; Processing: 8
;; Loading: 15
;; Loading: 16
;; Processing: 9
;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>From the output, it’s evident how the agent works. <code class="highlighter-rouge">Loading:</code> and <code class="highlighter-rouge">Processing:</code>
statements are interleaved in a seemingly random order. This is attributable to
the agent operating on a separate thread in the background. By introducing a
buffered sequence between the <code class="highlighter-rouge">load</code> and <code class="highlighter-rouge">process</code> we have a sort of
<strong>“pre-fetcher”</strong> which attempts to keep <em>at most</em> 5 items always realized
and ready to be processed.  As items are consumed from the buffer the agent
tries to replace them with new items from the unrealized sequence upstream. The
key difference compared to the chunked sequences is that while the chunked
sequences do not realize items until the first item of a chunk is requested,
buffered sequences realize enough items to fill the buffer ahead of the
consumption.</p>

<p><img src="/images/seque/seque.jpg" alt="seque" /></p>

<p><code class="highlighter-rouge">seque</code> is an excellent choice when it is important to minimize the wait-time on
consumer side and have items readily available. The important aspect is that it
allows for a configurable size. By carefully selecting the buffer size we
are able to control how many items (potentially big) are realized in memory at
any point in time. <code class="highlighter-rouge">seque</code> is truly a <code class="highlighter-rouge">clojure.core</code> hidden gem!</p>

<p>One thing to notice is that <code class="highlighter-rouge">seque</code> is semi-lazy as it will try to fill the
buffer as soon as it called. We can see this clearly if we define a var without
consuming the sequence.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">processing-seq</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">seque</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">;; buffer of 5
</span><span class="w">    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="n">Loading</span><span class="err">:</span><span class="w"> </span><span class="mi">6</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/processing-seq</span><span class="w">
</span></code></pre>
</div>

<p>Even though we created a buffer of 5 items we can see that there are 6 items
realized here. The buffer is backed by a blocking queue. The agent tries to
continuously push new items to the buffer, so when the buffer is full, there is
one more item being consumed from the upstream sequence by the agent who is
blocked on the queue <code class="highlighter-rouge">offer</code> operation. As soon as an item is consumed, the
<code class="highlighter-rouge">offer</code> will be accepted and the in-flight item will be inserted into the queue.</p>

<h2 id="parallel-pre-fetcher">Parallel pre-fetcher</h2>

<p>With a small change we can load the items in parallel. That’s useful when
the upstream operation (<code class="highlighter-rouge">load</code> in this case) is dominated by IO.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">load</span><span class="w"> </span><span class="n">v</span><span class="p">))))</span><span class="w"> </span><span class="c1">;; load in parallel
</span><span class="w">     </span><span class="p">(</span><span class="nf">seque</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">     </span><span class="c1">;; buffer up to 5 items (+1 in-flight)
</span><span class="w">     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">deref</span><span class="p">)</span><span class="w">   </span><span class="c1">;; deref the future
</span><span class="w">     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">
</span><span class="c1">;; Loading: 2
;; Loading: 3
;; Loading: 4
;; Loading: 6
;; Loading: 0
;; Loading: 5
;; Loading: 1
;; Loading: 7
;; Processing: 0
;; Processing: 1
;; Loading: 8
;; Processing: 2
;; Loading: 9
;; Processing: 3
;; Loading: 10
;; Processing: 4
;; Loading: 11
;; Processing: 5
;; Loading: 12
;; Processing: 6
;; Loading: 13
;; Processing: 7
;; Loading: 14
;; Processing: 8
;; Loading: 15
;; Processing: 9
;; Loading: 16
;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>With this small change we can fill the buffer faster especially in I/O dominated
operations.</p>

<p><img src="/images/seque/parallel.jpg" alt="parallel pre-fetch" /></p>

<p>We can easily isolate this pattern and create a <code class="highlighter-rouge">pre-fetch</code> function:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pre-fetch</span><span class="w">
  </span><span class="s">"Returns a semi-lazy sequence consisting of the result of applying
   `f` to items of `coll`. It is semi-lazy as it will attempt to keep
   always `n` items in a buffer + 1 item in flight.
   Useful to minimize the waiting time of a consumer."</span><span class="w">
  </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">coll</span><span class="w">
    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">i</span><span class="p">))))</span><span class="w">
    </span><span class="p">(</span><span class="nf">seque</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">deref</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>and then use it as:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">pre-fetch</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<h2 id="what-about-pmap">What about <code class="highlighter-rouge">pmap</code>?</h2>

<p><a href="https://clojuredocs.org/clojure.core/pmap"><code class="highlighter-rouge">pmap</code></a> has a similar behaviour but
you can’t control how many items are realized. It depends on the number of CPU
cores in available in the runtime machine.
<code class="highlighter-rouge">pmap</code> always uses <a href="https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/core.clj#L7021C12-L7021C61"><code class="highlighter-rouge">(+ 2 (.. Runtime getRuntime availableProcessors))</code></a> threads.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-lazy-seq</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">pmap</span><span class="w"> </span><span class="nb">load</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">doall</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Loading: 0
;; Loading: 1
;; Loading: 2
;; Loading: 4
;; Loading: 8
;; Loading: 3
;; Loading: 9
;; Loading: 7
;; Loading: 6
;; Loading: 5
;; Loading: 12
;; Loading: 11
;; Loading: 10
;; Processing: 0
;; Processing: 1
;; Loading: 13
;; Loading: 14
;; Processing: 2
;; Processing: 3
;; Loading: 15
;; Processing: 4
;; Loading: 16
;; Processing: 5
;; Loading: 17
;; Processing: 6
;; Loading: 18
;; Processing: 7
;; Loading: 19
;; Processing: 8
;; Loading: 20
;; Processing: 9
;; Loading: 21
;; =&gt; (0 1 2 3 4 5 6 7 8 9)
</span></code></pre>
</div>

<p>My laptop has 10 CPU cores so the <code class="highlighter-rouge">load</code> ran on 12 items.</p>

<p><img src="/images/seque/pmap.jpg" alt="pmap" /></p>

<h2 id="conclusions">Conclusions</h2>

<p>Throughout this post, we’ve delved into various types of lazy sequences and
examined their influence on the execution of mapping functions. We explored
three distinct categories of lazy sequences:</p>

<ol>
  <li>The “truly” lazy sequences, which realize items individually as they are requested.</li>
  <li>The chunked sequences, which process multiple items simultaneously.</li>
  <li>The buffered sequences, which consistently maintain a reservoir of realized items, ready for consumption.</li>
</ol>

<p>The salient distinction between chunked and buffered sequences lies in their
approach to realization. While chunked sequences await a consumer’s request for
an item, buffered sequences take a proactive stance, anticipating the need and
realizing a batch of items from the preceding sequence.</p>

<p>Each of these types occupies its unique niche and finds relevance in various
applications. It rests upon us, the developers, to judiciously select the most
fitting type tailored to the specific challenges we encounter.</p>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'bitsandpieces2'; // required: replace example with your forum shortname
        var disqus_config = function () {
          this.page.url = 'https://blog.brunobonacci.com/2023/09/08/buffered-sequences/';
          this.page.identifier = '/2023/09/08/buffered-sequences';
          this.page.title = 'Lazy, Chunked, and Buffered: Understanding Clojure's Lazy Sequences';
        };
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2013-2023 Bruno Bonacci. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51571233-1', 'auto');
  ga('send', 'pageview');
</script>


    </div>
  </body>
</html>